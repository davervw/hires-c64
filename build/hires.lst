
; ******** Source: code/hires.asm
     1                          ; hires.asm
     2                          ;
     3                          ; Commodore 64 High Resolution Graphics Functions
     4                          ; ported to 6502 by Dave Van Wagner (davevw.com)
     5                          ;
     6                          ; original graphics on/off and plot from BASIC program by Paul Soper
     7                          ;   https://paulnotebook.net/2019/06/08/plotting-a-function-in-hi-res-graphics-mode-on-a-commodore-64/
     8                          ;   who also credits https://archive.org/details/The_Graphics_Book_for_the_Commodore_64
     9                          ;
    10                          ; I credit my research to the following
    11                          ;   https://archive.org/details/Compute_s_Mapping_the_Commodore_64
    12                          ;   https://archive.org/details/c64-programmer-ref
    13                          ;   https://www.pagetable.com/c64disasm/
    14                          ;   https://dustlayer.com/c64-architecture/2013/4/13/ram-under-rom
    15                          ;   http://www.zimmers.net/cbmpics/cbm/c64/vic-ii.txt (see 2.4.2 Memory map as seen by the VIC)
    16                          ;
    17                          ; And there is compatibility built in with my ScrollEdit program published in 1988 (written in 1987)
    18                          ;   https://archive.org/details/1988-01-computegazette/page/n82
    19                          ;
    20                          ; original keyword extensions by Dave Van Wagner
    21                          ;
    22                          ; DVW added line graphics and shape routines (note: BASIC algorithm shown in comments)
    23                          ; and moved graphics to E000 under ROM and moved color ram to DC00 user ram
    24                          ; Implemented BASIC enhanced commands and functions
    25                          ; then implemented support for multiple graphic screens and drawing on non-active screen
    26                          ; added patch for compatibility with Scrolling BASIC Editor
    27                          ;
    28                          ; KNOWN ISSUES
    29                          ; 1. Running program multiple times, sometimes just does BRK - resets screen with READY.
    30                          ;
    31                          ; HIRES 0 - off, text
    32                          ; HIRES 1 - on, no clear
    33                          ; HIRES 1 CLR - on, w/ clear
    34                          ; HIRES 1[,gaddr[,caddr][CLR][PLOT]] - set graphics plotting address(es), copy old to alternate.  If PLOT specified, do not switch
    35                          ; HIRES 1,gaddr1[,caddr1]] SWAP gaddr2[,caddr2] - new syntax to allow specifying swap address(es)
    36                          ; HIRES 1 SWAP - swap graphics screen between primary and alternate - fast switching or copying bytes depending on configuration
    37                          ; HIRES 1 PUT - like SWAP but only copy *to* alternate screen
    38                          ; HIRES 1 GET - like SWAP but only copy *from* alternate screen
    39                          ; HIRES 0 PLOT - copy text screen to graphics screen
    40                          ; COLOR 0, fg, bg, bd - resolution mode, foreground, background, border (all optional. resolution mode defaults to 0/text)
    41                          ; COLOR 0, fg, bg @ row, col
    42                          ; COLOR 1, fg, bg, bd - change colors on hires screen
    43                          ; COLOR 1, fg, bg @ x, y - change pixel 8x8 cell colors
    44                          ; COLOR 1, fg, bg @ x1, y1 TO x2, y2 - change pixel 8x8 cell colors for region of screen
    45                          ; COLOR ,,,3 - change bg color
    46                          ; PLOT 1, x, y - set pixel
    47                          ; PLOT 0, x, y - clear pixel
    48                          ; PLOT 1 @ x,y - alternate syntax
    49                          ; PLOT 1 TO x2,y2
    50                          ; PLOT 1,x1,y1 TO x2,y2
    51                          ; PLOT 1,x1,y1 TO x2,y2 TO x3,y3 TO x4,y4 TO ...
    52                          ; PLOT 1 TO x2,y2 TO x3,y3 TO ...
    53                          ; PLOT 1,x1,y1,x2,y2 ... - alternate syntax
    54                          ; SHAPE PUT addr, x1,y1 TO x2,y2
    55                          ; SHAPE PUT OR addr, x1,y1 TO x2,y2
    56                          ; SHAPE PUT XOR addr, x1,y1 TO x2,y2
    57                          ; SHAPE PUT AND addr, x1,y1 TO x2,y2
    58                          ; SHAPE OR addr, x1,y1 TO x2,y2
    59                          ; SHAPE XOR addr, x1,y1 TO x2,y2
    60                          ; SHAPE AND addr, x1,y1 TO x2,y2
    61                          ; SHAPE NOT addr, x1,y1 to x2,y2
    62                          ; SHAPE GET addr,x1,y1,x2,y2
    63                          ; SHAPE GET addr, x1, y1 TO x2,y2
    64                          ; PATTERN addr @ x1,y1 TO x2,y2 - from pattern stored in memory
    65                          ; COLOR 0, fg @ r1, c1 TO r2, c2 - change text color for region of screen
    66                          ; PLOT 1,"ABC",x1,y1 - note CHR$(14) lowercase, CHR$(18) reverse on, +128 to turn options off
    67                          ; PLOT COLOR [fg][,bg] - temporarily color everything plotted, shape, and pattern, or clear options if no colors specified
    68                          ; PLOT 0,"ABC",x1,y1 - should remove image of letters from screen - equivalent to OR+XOR(NOT)
    69                          ; RECT pixel,x1,y1 TO x2,y2
    70                          ; RECT pixel @ x1,y1 TO x2,y2
    71                          ;
    72                          ; case 0 - init variables, set vectors, etc.
    73                          ; case 1 - graphics on
    74                          ; case 2 - set graphic memory address to predefined
    75                          ; case 3 - set color ram and initialize fg/bg cell colors
    76                          ; case 4 - graphics clear
    77                          ; case 5 - graphics off 
    78                          ; case 6 - plot point
    79                          ; case 7 - locate
    80                          ; case 8 - drawto
    81                          ; case 9 - shape size
    82                          ; case 10- shape get
    83                          ; case 11- shape/pattern put
    84                          ; case 12- screen swap
    85                          ; case 13- draw character at pixel location
    86                          ; case 14- set fg/bg 8x8 cell color at pixel location
    87                          ; case 15- text to graphics
    88                          
    89                          ; MEMORY MAP
    90                          ; 0000-00FF Zero Page (0.25K)
    91                          ; 0100-01FF Stack (0.25K)
    92                          ; 0200-03FF BASIC/Kernal Usage (0.5K)
    93                          ; 0400-07FF Text Screen (1K)
    94                          ; 0800-9FFF BASIC Program/Variables (38K)
    95                          ; A000-BFFF BASIC ROM // Hires bitmap SWAP (8K)
    96                          ; C000-CFFF Hires ML (4K)
    97                          ; D000-DBFF I/O and Text Color D800-DBFF // Character ROM D000-D7FF // Available RAM (except D800-DBFF 1K Hires SWAP color RAM) (3K)
    98                          ; DC00-DFFF Hires color RAM (1K)
    99                          ; E000-FFFF Kernal ROM // Hires bitmap (8K)
   100                          
   101                          start=$c000 ; machine language org
   102                          ;sc=$d800    ; graphics mode swap color ram (RAM Bank)
   103                          border=$d020; border color setting
   104                          scroly=$d011; and enable graphics
   105                          scrolx=$d016; and control register
   106                          vmcsb=$d018 ; vic-ii mem ctrl reg
   107                          syntax_error=$af08 ; BASIC ROM
   108                          illegal_quantity=$b248 ; BASIC ROM
   109                          chkcls=$aef7 ; checks for $29
   110                          chkopn=$aefa ; checks for $28
   111                          chkcom=$aefd ; checks for $2c
   112                          chkany=$aeff ; checks for character in accumulator
   113                          getbytc=$b79b ; parse byte expression from BASIC input
   114                          getnum=$b7eb ; 16-bit [$14,$15] comma 8-bit [x]
   115                          getadr=$b7f7 ; getadr - convert fp to 2 byte integer
   116                          frmnum=$ad8a ; evaluate expression, check data type
   117                          frmevl=$ad9e ; evaluate expression
   118                          listchr=$ab47 ; output a character
   119                          ayint=$b1bf ; convert fp to signed int
   120                          
   121                          ;zero page memory usage
   122                          arg1=$fb
   123                          arg2=$fc
   124                          arg3=$fd
   125                          arg4=$02
   126                          ptrl=$fe
   127                          ptrh=$ff
   128                          
   129                          ; "hires ml"
   130                          * = start
   131  c000 85fb                       sta arg1
   132  c002 86fc                       stx arg2
   133  c004 84fd                       sty arg3
   134  c006 08                         php
   135  c007 68                         pla
   136  c008 8502                       sta arg4 ; store register flags as 4th argument
   137                          
   138  c00a d8                         cld ; clear decimal flag just in case
   139                                  ;cli ; clear interrupt flag just in case
   140                          
   141  c00b a5fb                       lda arg1
   142  c00d c900                       cmp #0
   143  c00f f010                       beq case0
   144  c011 4c9bc0                     jmp try1
   145                          
   146  c014 00                 option_plotting !byte 0
   147  c015 00                 option_alternate !byte 0
   148  c016 00                 option_apply_color !byte 0
   149  c017 00                 option_colors_0 !byte 0
   150  c018 00                 option_colors_1 !byte 0
   151  c019 00                 option_colors_2 !byte 0
   152  c01a 00                 option_colors_3 !byte 0
   153  c01b 00                 option_colors_4 !byte 0
   154  c01c 00                 option_colors_5 !byte 0
   155  c01d 00                 option_colors_6 !byte 0
   156  c01e 00                 option_colors_7 !byte 0
   157  c01f 0e                 option_hiresfg !byte 14
   158  c020 06                 option_hiresbg !byte 6
   159                          
   160                          case0 ; init
   161  c021 8d16c0                     sta option_apply_color
   162  c024 ad1fc0                     lda option_hiresfg
   163  c027 ad20c0                     lda option_hiresbg
   164                          
   165  c02a a939                       lda #<basic_error
   166  c02c 8d0003                     sta $300
   167  c02f a9cf                       lda #>basic_error
   168  c031 8d0103                     sta $301
   169                          
   170  c034 a90d                       lda #<hires_crunch
   171  c036 8d0403                     sta $304
   172  c039 a9c8                       lda #>hires_crunch
   173  c03b 8d0503                     sta $305
   174                          
   175  c03e a9d1                       lda #<list_tokens
   176  c040 8d0603                     sta $306
   177  c043 a9c7                       lda #>list_tokens
   178  c045 8d0703                     sta $307
   179                          
   180  c048 a928                       lda #<execute
   181  c04a 8d0803                     sta $308
   182  c04d a9c9                       lda #>execute
   183  c04f 8d0903                     sta $309
   184                          
   185  c052 a9e0                       lda #$e0
   186  c054 8d14c0                     sta option_plotting
   187  c057 a9a0                       lda #$a0
   188  c059 8d15c0                     sta option_alternate
   189                          
   190  c05c a900                       lda #0 ; not available
   191  c05e 8d17c0                     sta option_colors_0
   192  c061 8d1bc0                     sta option_colors_4
   193  c064 8d1dc0                     sta option_colors_6
   194  c067 a90c                       lda #$0C
   195  c069 8d18c0                     sta option_colors_1
   196  c06c a960                       lda #$60
   197  c06e 8d19c0                     sta option_colors_2
   198  c071 a95c                       lda #$5C
   199  c073 8d1ac0                     sta option_colors_3
   200  c076 a9d8                       lda #$D8 ; should switch to $8C (or $80, $84, $88) for hardware supported color address
   201  c078 8d1cc0                     sta option_colors_5
   202  c07b a9dc                       lda #$DC
   203  c07d 8d1ec0                     sta option_colors_7
   204                          
   205  c080 20a6cf                     jsr scrledit_patch
   206                          
   207  c083 2089c0                     jsr install_no_interrupt
   208                          
   209  c086 4cb1c8                     jmp crunch_patch
   210                          
   211                          install_no_interrupt
   212  c089 a99a                       lda #<no_interrupt
   213  c08b 8dfaff                     sta $fffa
   214  c08e 8dfcff                     sta $fffc
   215  c091 a9c0                       lda #>no_interrupt
   216  c093 8dfbff                     sta $fffb
   217  c096 8dfdff                     sta $fffd
   218  c099 60                         rts
   219                          
   220                          no_interrupt ; just return
   221  c09a 40                         rti
   222                          
   223  c09b c901               try1    cmp #$01
   224  c09d d011                       bne try2
   225                          
   226                          ; case 1 - init graphics
   227  c09f ad11d0                     lda scroly
   228  c0a2 09b0                       ora #$b0 ; set bits 7,5,4
   229  c0a4 8d11d0                     sta scroly
   230  c0a7 ad16d0                     lda scrolx
   231  c0aa 29ef                       and #$ef ; turn off bit 4
   232  c0ac 8d16d0                     sta scrolx
   233  c0af 60                         rts
   234                          
   235                          try2
   236  c0b0 c902                       cmp #$02
   237  c0b2 d03b                       bne try3
   238                          
   239                                  ; case 2 - set graphic ram area
   240  c0b4 ad14c0                     lda option_plotting
   241  c0b7 85fb                       sta arg1
   242  c0b9 ad00dd                     lda $dd00
   243  c0bc 4a                         lsr             ; shift out bit0
   244  c0bd 4a                         lsr             ; shift out bit1
   245  c0be 06fb                       asl arg1        ; c=hires address bit 7
   246  c0c0 2a                         rol             ; shift in bit1
   247  c0c1 06fb                       asl arg1        ; c=hires address bit 6
   248  c0c3 2a                         rol             ; shift in bit0
   249  c0c4 4903                       eor #$03        ; toggle bits for vic-ii
   250  c0c6 48                         pha
   251                          
   252  c0c7 ad14c0                     lda option_plotting
   253  c0ca 206cc5                     jsr hires_to_color
   254  c0cd 293c                       and #$3C        ; valid bits for color address
   255  c0cf 0a                         asl
   256  c0d0 0a                         asl             ; convert to $00..$70, high nibble is 1K bank for color
   257  c0d1 06fb                       asl arg1        ; c=hires address bit 5
   258  c0d3 9002                       bcc +
   259  c0d5 0908                       ora #$08
   260  c0d7 8d18d0             +       sta vmcsb
   261                          
   262  c0da 68                         pla
   263  c0db 8d00dd                     sta $dd00 ;switch to vic-ii bank associated with hires address
   264                          
   265  c0de 60                         rts
   266                          
   267                          bankram
   268  c0df 78                         sei      ; disable interrupts
   269  c0e0 a501                       lda $01
   270  c0e2 29f8                       and #$f8 ; mask out bits 0,1,2
   271  c0e4 8501                       sta $01  ; a000-ffff is now ram, no i/o
   272  c0e6 60                 	rts
   273                          
   274                          banknorm
   275  c0e7 a501                       lda $01
   276  c0e9 0907                       ora #$07        ; a000-ffff is back to defaults
   277  c0eb 8501                       sta $01
   278  c0ed 58                         cli
   279  c0ee 60                 	rts
   280                          
   281                          try3
   282  c0ef c903                       cmp #$03
   283  c0f1 d009                       bne try4
   284                          
   285                                  ; case 3 - set color ram
   286  c0f3 20dfc0             	jsr bankram
   287  c0f6 201dd0             	jsr case3
   288  c0f9 4ce7c0             	jmp banknorm
   289                          
   290                          try4
   291  c0fc c904                       cmp #$04
   292  c0fe d009                       bne try5
   293                          
   294                                  ; case 4 - clear graphic ram
   295  c100 20dfc0             	jsr bankram
   296  c103 203bd0             	jsr case4
   297  c106 4ce7c0             	jmp banknorm
   298                          
   299                          try5
   300  c109 c905                       cmp #$05
   301  c10b d01e                       bne try6
   302                          
   303                          ; case 5 - turn graphics off
   304  c10d ad11d0                     lda scroly
   305  c110 299f                       and #$9f ; clr bits 5/6
   306  c112 8d11d0                     sta scroly
   307  c115 ad16d0                     lda scrolx
   308  c118 29ef                       and #$ef ; clr bit 4
   309  c11a 8d16d0                     sta scrolx
   310  c11d a914                       lda #$14
   311  c11f 8d18d0                     sta vmcsb
   312  c122 ad00dd                     lda $dd00
   313  c125 0903                       ora #$03  ; set bits 0,1
   314  c127 8d00dd                     sta $dd00 ;switch to vicii bank 0
   315  c12a 60                         rts
   316                          
   317                          try6
   318  c12b c906                       cmp #$06
   319  c12d f003                       beq is6
   320  c12f 4ca0c1                     jmp try7
   321                          
   322                          is6
   323  c132 20dfc0             	jsr bankram
   324  c135 2059d0                     jsr case6
   325  c138 4ce7c0                     jmp banknorm
   326                          
   327                          xyaddr ; given coordinates in x1lo, x1hi, y1 calculate ptrl/ptrh on screen
   328                          
   329  c13b a5fb                       lda arg1 ; we're gonna trash arg1,arg2 so save original values on stack
   330  c13d 48                         pha
   331  c13e a5fc                       lda arg2
   332  c140 48                         pha
   333                          
   334  c141 ad65cf                     lda y1
   335  c144 29f8                       and #$f8 ; int(yc/8)*8
   336  c146 85fb                       sta arg1
   337  c148 a900                       lda #$00
   338  c14a 85fc                       sta arg2
   339  c14c 06fb                       asl arg1 ; *2 more (=*16)
   340  c14e 26fc                       rol arg2
   341  c150 06fb                       asl arg1 ; *2 more (=*32)
   342  c152 26fc                       rol arg2
   343  c154 06fb                       asl arg1 ; *2 more (=*64)
   344  c156 26fc                       rol arg2
   345  c158 a205                       ldx #5  ; setup *5 more (=*320)
   346  c15a a900                       lda #$00
   347  c15c 85fe                       sta ptrl ; zero out result
   348  c15e 85ff                       sta ptrh
   349                          
   350                          mult5
   351  c160 18                         clc
   352  c161 a5fe                       lda ptrl
   353  c163 65fb                       adc arg1
   354  c165 85fe                       sta ptrl
   355  c167 a5ff                       lda ptrh
   356  c169 65fc                       adc arg2
   357  c16b 85ff                       sta ptrh
   358  c16d ca                         dex
   359  c16e d0f0                       bne mult5 ; loop until *320 done
   360                          
   361  c170 ad65cf                     lda y1
   362  c173 2907                       and #$07
   363  c175 18                         clc
   364  c176 65fe                       adc ptrl ; ptr += yc and 7
   365  c178 85fe                       sta ptrl
   366  c17a a5ff                       lda ptrh
   367  c17c 6900                       adc #$00
   368  c17e 85ff                       sta ptrh
   369                          
   370  c180 ad63cf                     lda x1lo
   371  c183 29f8                       and#$f8 ; 8*int(xc/8)
   372  c185 18                         clc
   373  c186 65fe                       adc ptrl  ; ptr += 8*int(xc/8)
   374  c188 85fe                       sta ptrl
   375  c18a ad64cf                     lda x1hi
   376  c18d 65ff                       adc ptrh
   377  c18f 85ff                       sta ptrh
   378                          
   379  c191 18                         clc       ; add offset to graphics adapter
   380  c192 a5ff                       lda ptrh
   381  c194 6d14c0                     adc option_plotting
   382  c197 85ff                       sta ptrh
   383                          
   384  c199 68                         pla      ; restore original values of arg1,arg2 from stack
   385  c19a 85fc                       sta arg2
   386  c19c 68                         pla
   387  c19d 85fb                       sta arg1
   388                          
   389  c19f 60                         rts
   390                          
   391                          try7
   392  c1a0 c907                       cmp #7
   393  c1a2 f036                       beq case7
   394  c1a4 c908                       cmp #8
   395  c1a6 f044                       beq case8
   396  c1a8 c909                       cmp #9
   397  c1aa d003                       bne +
   398  c1ac 4c06c2                     jmp case9
   399  c1af c90a               +       cmp #10
   400  c1b1 d003                       bne +
   401  c1b3 4c68c2                     jmp case10
   402  c1b6 c90b               +       cmp #11
   403  c1b8 d003                       bne +
   404  c1ba 4c5cc3                     jmp case11
   405  c1bd c90c               +       cmp #12
   406  c1bf d003                       bne +
   407  c1c1 4c63c5                     jmp case12
   408  c1c4 c90d               +       cmp #13
   409  c1c6 d003                       bne +
   410  c1c8 4c76c5                     jmp case13
   411  c1cb c90e               +       cmp #14
   412  c1cd d003                       bne +
   413  c1cf 4cf5c5                     jmp case14
   414  c1d2 c90f               +       cmp #15
   415  c1d4 d003                       bne +
   416  c1d6 4cdbc6                     jmp case15
   417  c1d9 60                 +       rts ; default case - do nothing
   418                          
   419                          ; line graphics algorithm implemented by davevw
   420                          ; from memory from the 80s, and it worked!
   421                          ;
   422                          ; 32000 xs=x2-x1:ys=y2-y1
   423                          ; 32010 if abs(xs) < abs(ys) then 32100
   424                          ; 32020 yc=y1:yf=0:xi=xs/abs(xs)
   425                          ; 32030 for xc=x1 to x2 step xi
   426                          ; 32040 gosub 30000 ; rem plot point xc,yc
   427                          ; 32050 yf=yf+ys
   428                          ; 32060 if (ys>0 and yf>=abs(xs)) then yc=yc+1:yf=yf-abs(xs)
   429                          ; 32070 if (ys<0 and yf<=-abs(xs)) then yc=yc-1:yf=yf+abs(xs)
   430                          ; 32080 next xc
   431                          ; 32090 return
   432                          ; 32100 xc=x1:xf=0:yi=ys/abs(ys)
   433                          ; 32110 for yc=y1 to y2 step yi
   434                          ; 32120 gosub 30000 ; rem plot point xc,yc
   435                          ; 32130 xf=xf+xs
   436                          ; 32140 if (xs>0 and xf>=abs(ys)) then xc=xc+1:xf=xf-abs(ys)
   437                          ; 32150 if (xs<0 and xf<=-abs(ys)) then xc=xc-1:xf=xf+abs(ys)
   438                          ; 32160 next yc
   439                          ; 32170 return
   440                          
   441                          case7 ; locate x1, y1
   442  c1da a5fc                       lda arg2
   443  c1dc 8d63cf                     sta x1lo
   444  c1df a5fd                       lda arg3
   445  c1e1 8d65cf                     sta y1
   446  c1e4 a502                       lda arg4
   447  c1e6 2901                       and #$01
   448  c1e8 8d64cf                     sta x1hi
   449  c1eb 60                         rts
   450                          
   451                          case8 ; draw line to x2, y2
   452  c1ec a5fc                       lda arg2 ; store arguments at x2, y2
   453  c1ee 8d66cf                     sta x2lo
   454  c1f1 a5fd                       lda arg3
   455  c1f3 8d68cf                     sta y2
   456  c1f6 a502                       lda arg4
   457  c1f8 2901                       and #$01
   458  c1fa 8d67cf                     sta x2hi
   459                          
   460  c1fd 20dfc0             	jsr bankram
   461  c200 20cfd0                     jsr line
   462  c203 4ce7c0             	jmp banknorm
   463                                  ; note x1,y1 should match x2,y2 at this point
   464                          
   465                          ; test code for shape size
   466                          ; (dependency: locate)
   467                          ; 33000 rem locate x1,y1
   468                          ; 33001 poke 780,9:poke 781,x1 and 255:poke 782,y1:poke 783,x1/256:sys ml
   469                          ; 33002 return
   470                          ; 35000 rem size shape to x2,y2
   471                          ; 35001 poke 780,9:poke 781,x2 and 255:poke 782,y2:poke 783,x2/256:sys ml
   472                          ; 35002 sz=peek(781)+256*peek(782)
   473                          ; 35003 return
   474                          ; ml=49152:x1=0:y1=0:x2=319:y2=199:gosub 33000:gosub 35000:print sz
   475                          
   476                          case9                   ; shape size
   477  c206 a5fc                       lda arg2
   478  c208 8d66cf                     sta x2lo
   479  c20b a5fd                       lda arg3
   480  c20d 8d68cf                     sta y2
   481  c210 a502                       lda arg4
   482  c212 2901                       and #$01
   483  c214 8d67cf                     sta x2hi
   484                          
   485  c217 ae66cf             case9c  ldx x2lo        ; increment x2 one pixel for size
   486  c21a ac67cf                     ldy x2hi        ; in registers only so don't affect values
   487  c21d e8                         inx
   488  c21e d001                       bne +
   489  c220 c8                         iny
   490  c221 38                 +       sec
   491  c222 8a                         txa             ; (x2+1)lo
   492  c223 ed63cf                     sbc x1lo
   493  c226 8d69cf                     sta xslo
   494  c229 98                         tya             ; (x2+1)hi
   495  c22a ed64cf                     sbc x1hi
   496  c22d 8d6acf                     sta xshi
   497  c230 3031                       bmi sizeinvalid
   498  c232 0d69cf                     ora xslo
   499  c235 f02c                       beq sizeinvalid
   500  c237 ac68cf                     ldy y2
   501  c23a c8                         iny             ; increment for size without affecting memory
   502  c23b 98                         tya
   503  c23c ed65cf                     sbc y1
   504  c23f 8d6bcf                     sta yslo
   505  c242 901f                       bcc sizeinvalid
   506  c244 f01d                       beq sizeinvalid
   507  c246 18                         clc
   508  c247 ad69cf                     lda xslo
   509  c24a 6907                       adc #$07        ; round up to nearest 8 bits
   510  c24c 29f8                       and #$F8        ; mask out lower bits
   511  c24e ae6acf                     ldx xshi        ; retrieve high byte
   512  c251 9001                       bcc +
   513  c253 e8                         inx             ; carry increases high byte
   514  c254 a8                 +       tay             ; save A
   515  c255 8a                         txa             ; retrieve high byte
   516  c256 4a                         lsr             ; transfer high bit into carry
   517  c257 98                         tya             ; retrieve A
   518  c258 6a                         ror             ; /2 with high bit rotating in
   519  c259 4a                         lsr             ; /2
   520  c25a 4a                         lsr             ; /2
   521  c25b aa                         tax
   522  c25c ac6bcf                     ldy yslo
   523  c25f 2099c7                     jsr multxy      ; xy=x*y
   524  c262 60                         rts             ; have answer
   525                          sizeinvalid
   526  c263 a900                       lda #$00
   527  c265 aa                         tax
   528  c266 a8                         tay
   529  c267 60                         rts
   530                          
   531                          case10  ; shape get to (X2,Y2), see locate and shape size, input dst ptr
   532                                  ; create multiply function to position to (X1,Y1) address ptr -> src
   533                                  ; shift = (X1 AND 7)
   534                                  ; right_mod = ((X2+1-X1) AND 7);
   535                                  ; right_mask = (255 << (8-right_mod)) AND 255;
   536                                  ; // 0:255, 1:128, 2:192, ..., 7:254
   537                                  ; columns = int((x2+1-x1+7)/8)
   538                                  ; do
   539                                  ; {
   540                                  ;   ys = y2+1-y1;
   541                                  ;   do
   542                                  ;   {
   543                                  ;     *dst = (*src << shift) | ((*(src+8) << shift) >> 8)
   544                                  ;     if (columns == 1)
   545                                  ;       *dst = *dst & right_mask;
   546                                  ;     ++dst;
   547                                  ;     ++src;
   548                                  ;     if ((src & 7) == 0)
   549                                  ;        src += 312;
   550                                  ;   } while (--ys > 0);
   551                                  ;   x1 += 8;
   552                                  ;   src = xyaddr(x1, y1)
   553                                  ; } while (--columns > 0);
   554                          
   555  c268 2017c2                     jsr case9c      ; get shape size, verify not invalid
   556  c26b e000                       cpx #$00
   557  c26d d00d                       bne +
   558  c26f c000                       cpy #$00
   559  c271 d009                       bne +
   560  c273 85fe                       sta ptrl        ; wipe out source address
   561  c275 85ff                       sta ptrh
   562  c277 a6fe                       ldx ptrl        ; return null address end to signal error
   563  c279 a4ff                       ldy ptrh
   564  c27b 60                         rts             ; FAILED
   565                          
   566  c27c 203bc1             +       jsr xyaddr      ; get address of (X,Y)
   567                          
   568  c27f ad63cf                     lda x1lo
   569  c282 2907                       and #$07
   570  c284 85fb                       sta arg1        ; shift
   571                          
   572  c286 ae66cf                     ldx x2lo
   573  c289 e8                         inx
   574  c28a 8a                         txa
   575  c28b 38                         sec
   576  c28c ed63cf                     sbc x1lo
   577  c28f 2907                       and #$07
   578  c291 aa                         tax
   579  c292 a9ff                       lda #$ff
   580  c294 e000                       cpx #$00
   581  c296 f007                       beq +
   582  c298 a900                       lda #0
   583  c29a 38                 -       sec
   584  c29b 6a                         ror
   585  c29c ca                         dex
   586  c29d d0fb                       bne -
   587  c29f 8502               +       sta arg4        ; right_mask
   588                          
   589  c2a1 ac67cf                     ldy x2hi        ; calculate x distance
   590  c2a4 ae66cf                     ldx x2lo
   591  c2a7 e8                         inx
   592  c2a8 d001                       bne +
   593  c2aa c8                         iny
   594  c2ab 38                 +       sec
   595  c2ac 8a                         txa
   596  c2ad ed63cf                     sbc x1lo
   597  c2b0 8d69cf                     sta xslo
   598  c2b3 98                         tya
   599  c2b4 ed64cf                     sbc x1hi
   600  c2b7 8d6acf                     sta xshi
   601                          
   602  c2ba 18                         clc             ; round up to full byte
   603  c2bb ad69cf                     lda xslo
   604  c2be 6907                       adc #7
   605  c2c0 29f8                       and #$F8
   606  c2c2 8d69cf                     sta xslo
   607  c2c5 9003                       bcc +
   608  c2c7 ee6acf                     inc xshi
   609                          +
   610                          
   611  c2ca 4e6acf                     lsr xshi        ; divide x distance by 8, result fits in byte
   612  c2cd 6e69cf                     ror xslo
   613  c2d0 4e69cf                     lsr xslo
   614  c2d3 4e69cf                     lsr xslo
   615                          
   616  c2d6 ac68cf                     ldy y2          ; calculate y distance
   617  c2d9 c8                         iny
   618  c2da 98                         tya
   619  c2db 38                         sec
   620  c2dc ed65cf                     sbc y1
   621  c2df 8d6bcf                     sta yslo
   622  c2e2 8d6ccf                     sta yshi
   623                          
   624  c2e5 20dfc0             	jsr bankram
   625                          
   626                                                  ; for y=Y1 to Y2 (in count only)
   627                                                  ; for x=X1 to X2 step 8 (in count only)
   628  c2e8 a000                       ldy #$00        ; clear pointer offset
   629                          
   630  c2ea b1fe               --      lda (ptrl),y    ; retrieve this column
   631  c2ec 8d6dcf                     sta fraclo      ; left column
   632  c2ef a008                       ldy #8          ; next column is only 8 bytes away
   633  c2f1 b1fe                       lda (ptrl),y    ; retrieve from next column to right
   634  c2f3 8d6ecf                     sta frachi      ; right column
   635  c2f6 a6fb                       ldx arg1        ; retrieve shift count again for loop
   636  c2f8 f009                       beq +
   637  c2fa 0e6ecf             -       asl frachi      ; shift right bits, direction left
   638  c2fd 2e6dcf                     rol fraclo      ; rotate carry into left bits, direction left
   639  c300 ca                         dex
   640  c301 d0f7                       bne -           ; repeat
   641  c303 ad6dcf             +       lda fraclo      ; get shifted bits for this column
   642  c306 ae69cf                     ldx xslo
   643  c309 e001                       cpx #1          ; last column?
   644  c30b d002                       bne +           ; no - so skip
   645  c30d 2502                       and arg4        ; and right_mask
   646  c30f a000               +       ldy #0          ; clear pointer offset
   647  c311 91fc                       sta (arg2),y    ; store resulting data
   648                          
   649  c313 e6fe                       inc ptrl        ; ++ptr
   650  c315 d002                       bne +
   651  c317 e6ff                       inc ptrh
   652  c319 a5fe               +       lda ptrl
   653                          
   654  c31b 2907                       and #$07        ; (ptr & 7) == 0) ?
   655  c31d d00d                       bne +           ; branch if no
   656  c31f 18                         clc             ; yes - ptr += 312
   657  c320 a5fe                       lda ptrl
   658  c322 6938                       adc #<312
   659  c324 85fe                       sta ptrl
   660  c326 a5ff                       lda ptrh
   661  c328 6901                       adc #>312
   662  c32a 85ff                       sta ptrh
   663                          
   664  c32c e6fc               +       inc arg2        ; ++dst
   665  c32e d002                       bne +
   666  c330 e6fd                       inc arg3
   667                          
   668  c332 ce6bcf             +       dec yslo        ; next y
   669  c335 d0b3                       bne --
   670                          
   671  c337 18                         clc             ; x1 += 8
   672  c338 ad63cf                     lda x1lo
   673  c33b 6908                       adc #8
   674  c33d 8d63cf                     sta x1lo
   675  c340 9003                       bcc +
   676  c342 ee64cf                     inc x1hi
   677                          
   678  c345 203bc1             +       jsr xyaddr     ; get next src addr into ptr
   679                          
   680  c348 ad6ccf                     lda yshi        ; restore y distance
   681  c34b 8d6bcf                     sta yslo
   682                          
   683  c34e ce69cf                     dec xslo        ; next x column (always a byte)
   684  c351 d097                       bne --
   685                          
   686  c353 a5fc                       lda arg2        ; put end of buffer in x,y registers
   687  c355 aa                         tax
   688  c356 a5fd                       lda arg3
   689  c358 a8                         tay
   690                          
   691  c359 4ce7c0             	jmp banknorm
   692                          
   693                          case11  ; shape put to (X2,Y2), see locate and shape size, input src ptr
   694                                  ; create multiply function to position to (X1,Y1) address ptr -> dst
   695                                  ; shift = (X1 AND 7);
   696                                  ; left_mask = 255 >> shift;
   697                                  ; right_mask = fn(X2 AND 7) = 0:128,1:192,2:224,3:240,4:248,5:252,6:254,7:255
   698                                  ; columns = int((x2+1-(x1 and 248)+7)/8); // screen columns
   699                                  ; if (columns == 1)
   700                                  ; {
   701                                  ;   left_mask = left_mask and right_mask;
   702                                  ;   right_mask = left_mask;
   703                                  ; }
   704                                  ; do
   705                                  ; {
   706                                  ;   ys = y2+1-y1;
   707                                  ;   do
   708                                  ;   {
   709                                  ;     if (left_mask != 255)
   710                                  ;       data = (*src >> shift); // left-most column
   711                                  ;     else
   712                                  ;       data = ((*(src-(y2+1-y1)) << 8) >> shift) | (*src >> shift); // other
   713                                  ;     if (columns == 1)
   714                                  ;       *dst = *dst & (^right_mask) | (data & right_mask);
   715                                  ;     else if (left_mask = 255)
   716                                  ;       *dst = data;
   717                                  ;     else
   718                                  ;       *dst = *dst & (^left_mask) | (data & left_mask);
   719                                  ;     ++dst;
   720                                  ;     if ((dst & 7) == 0)
   721                                  ;        dst += 312;
   722                                  ;     ++src;
   723                                  ;   } while (--ys > 0);
   724                                  ;   x1 += 8;
   725                                  ;   left_mask = 255;
   726                                  ;   dst = xyaddr(x1, y1)
   727                                  ; } while (--columns > 0);
   728                          
   729  c35c a900                       lda #0
   730  c35e 8d5dcf                     sta pattern_flag ; *NOT* PATTERN
   731                          case11b
   732  c361 a502                       lda arg4        ; flags
   733  c363 2943                       and #$43        ; mask to flags we care about
   734  c365 8d6ecf             +       sta frachi      ; save shape mode: 0x00=normal, 0x01=or, 0x02=and, 0x03=eor, 0x04=not
   735                          
   736  c368 2017c2                     jsr case9c      ; get shape size, verify not invalid
   737  c36b e000                       cpx #$00
   738  c36d d009                       bne +
   739  c36f c000                       cpy #$00
   740  c371 d005                       bne +
   741  c373 85fe                       sta ptrl        ; wipe out source address
   742  c375 85ff                       sta ptrh
   743  c377 60                         rts             ; FAILED
   744                          
   745  c378 203bc1             +       jsr xyaddr      ; get address of (X,Y)
   746                          
   747  c37b ad65cf                     lda y1
   748  c37e 8d74cf                     sta case14_yslo ; save copy of y1 in case applying color later
   749  c381 ad64cf                     lda x1hi
   750  c384 8d73cf                     sta case14_xshi ; save copy of x1hi in case applying color later
   751  c387 ad63cf                     lda x1lo
   752  c38a 8d72cf                     sta case14_xslo ; save copy of x1lo in case applying color later
   753  c38d 2907                       and #$07
   754  c38f 85fb                       sta arg1        ; shift
   755                          
   756  c391 ad66cf                     lda x2lo        ; calculate right_mask, based solely on x2 bit position
   757  c394 2907                       and #$07
   758  c396 aa                         tax
   759  c397 e8                         inx
   760  c398 38                 -       sec
   761  c399 6a                         ror
   762  c39a ca                         dex
   763  c39b d0fb                       bne -
   764  c39d 8502               +       sta arg4        ; right_mask
   765                          
   766  c39f ad63cf                     lda x1lo        ; include full left column screen byte
   767  c3a2 29f8                       and #$f8        ;   so will count all screen columns necessary for shape put
   768  c3a4 8d63cf                     sta x1lo
   769                          
   770  c3a7 ac67cf                     ldy x2hi        ; calculate x distance
   771  c3aa ae66cf                     ldx x2lo
   772  c3ad e8                         inx
   773  c3ae d001                       bne +
   774  c3b0 c8                         iny
   775  c3b1 38                 +       sec
   776  c3b2 8a                         txa
   777  c3b3 ed63cf                     sbc x1lo
   778  c3b6 8d69cf                     sta xslo
   779  c3b9 98                         tya
   780  c3ba ed64cf                     sbc x1hi
   781  c3bd 8d6acf                     sta xshi
   782                          
   783  c3c0 18                         clc             ; round up to full byte
   784  c3c1 ad69cf                     lda xslo
   785  c3c4 6907                       adc #7
   786  c3c6 29f8                       and #$F8
   787  c3c8 8d69cf                     sta xslo
   788  c3cb 9003                       bcc +
   789  c3cd ee6acf                     inc xshi
   790                          +
   791                          
   792  c3d0 4e6acf                     lsr xshi        ; divide x distance by 8, result fits in byte
   793  c3d3 6e69cf                     ror xslo
   794  c3d6 4e69cf                     lsr xslo
   795  c3d9 4e69cf                     lsr xslo
   796                          
   797  c3dc ac68cf                     ldy y2          ; calculate y distance
   798  c3df c8                         iny
   799  c3e0 98                         tya
   800  c3e1 38                         sec
   801  c3e2 ed65cf                     sbc y1
   802  c3e5 8d6bcf                     sta yslo
   803  c3e8 8d6ccf                     sta yshi
   804                          
   805  c3eb a9ff                       lda #$ff        ; calculate left_mask
   806  c3ed a6fb                       ldx arg1        ; shift
   807  c3ef f004                       beq +
   808  c3f1 4a                 -       lsr
   809  c3f2 ca                         dex
   810  c3f3 d0fc                       bne -
   811  c3f5 8d6acf             +       sta xshi        ; left_mask
   812                          
   813                                  ; if one column, left_mask and right_mask need combining into one mask
   814  c3f8 ae69cf                     ldx xslo        ; columns
   815  c3fb e001                       cpx #$01        ; 1?
   816  c3fd d007                       bne +           ; no, skip this
   817  c3ff 2502                       and arg4        ; yes, combine with right_mask
   818  c401 8502                       sta arg4        ; store right_mask
   819  c403 8d6acf                     sta xshi        ; store left_mask
   820                          
   821  c406 78                 +       sei
   822  c407 a501                       lda $01
   823  c409 2907                       and #7
   824  c40b c907                       cmp #7
   825  c40d f009                       beq +
   826  c40f a501                       lda $01         ; non-default bank already selected (e.g. char rom visible)
   827  c411 29fd                       and #$fd        ; mask out only bit 1
   828  c413 8501                       sta $01         ; make sure e000-ffff is now ram, no i/o
   829  c415 4c1ec4                     jmp ++
   830  c418 a501               +       lda $01
   831  c41a 29f8                       and #$f8        ; mask out bits 0,1,2
   832  c41c 8501                       sta $01         ; all 64k ram
   833                          
   834  c41e a901               ++      lda #01
   835  c420 8d6fcf                     sta incr        ; record that this is the first column
   836                          
   837                                                  ; for y=Y1 to Y2 (in count only)
   838                                                  ; for x=X1 to X2 step 8 (in count only)
   839                          
   840  c423 a000                       ldy #$00        ; clear pointer offset
   841                          
   842  c425 2c5dcf             --      bit pattern_flag
   843  c428 7028                       bvs .pattern_case
   844                          
   845                                  ;shape case
   846  c42a b1fc                       lda (arg2),y    ; retrieve shape data from memory
   847  c42c ae6fcf                     ldx incr        ; left-most column flag? simple case, no data to our left
   848  c42f f00a                       beq +           ; no - skip to general case
   849  c431 a6fb                       ldx arg1        ; shift count
   850  c433 f035                       beq ++          ; simple case - no shift, branch to store
   851  c435 4a                 -       lsr             ; shift data right by count
   852  c436 ca                         dex
   853  c437 d0fc                       bne -           ; repeat until done
   854  c439 f02f                       beq ++          ; skip over general case
   855                          
   856  c43b 8d6dcf             +       sta fraclo      ; left data
   857  c43e ac6ccf                     ldy yshi        ; y size
   858  c441 b1fc                       lda (arg2),y    ; load this column data
   859  c443 a000                       ldy #0          ; reset index for pointers
   860  c445 a6fb                       ldx arg1        ; shift count
   861  c447 f021                       beq ++          ; done with this case
   862  c449 4e6dcf             -       lsr fraclo      ; rotate left data
   863  c44c 6a                         ror             ; rotate carry into right data
   864  c44d ca                         dex
   865  c44e d0f9                       bne -           ; repeat until done
   866  c450 f018                       beq ++          ; skip over pattern_case
   867                          
   868                          .pattern_case
   869  c452 a5fe                       lda ptrl
   870  c454 2907                       and #$07
   871  c456 a8                         tay
   872  c457 b1fc                       lda (arg2),y    ; retrieve shape data from memory
   873  c459 ae6fcf                     ldx incr        ; left-most column flag? simple case, no data to our left
   874  c45c d005                       bne +
   875  c45e 2d6acf                     and xshi
   876  c461 f005                       beq .pattern_case_exit ; skip over general case
   877                          
   878  c463 8d6dcf             +       sta fraclo      ; left data
   879  c466 b1fc                       lda (arg2),y    ; load next column data
   880                          .pattern_case_exit
   881  c468 a000                       ldy #0          ; reset index for storage
   882                          
   883                                  ; check if columns = 1 (last column)
   884  c46a ae69cf             ++      ldx xslo        ; column
   885  c46d e001                       cpx #1          ; last?
   886  c46f d00c                       bne +
   887  c471 2502                       and arg4        ; right_mask
   888  c473 8d6dcf                     sta fraclo
   889  c476 a502                       lda arg4
   890  c478 49ff                       eor #$ff
   891  c47a 4c97c4                     jmp ++
   892                          
   893                                  ; check if general interior case, simple store
   894  c47d ae6acf             +       ldx xshi        ; left_mask
   895  c480 e0ff                       cpx #$ff        ; left most?
   896  c482 d008                       bne +           ; no, branch to left case
   897  c484 8d6dcf                     sta fraclo      ; simple case, just store
   898  c487 a900                       lda #$00
   899  c489 4c97c4                     jmp ++
   900                          
   901                                  ; handle first column case where shift was required
   902  c48c 2d6acf             +       and xshi        ; left_mask
   903  c48f 8d6dcf                     sta fraclo
   904  c492 ad6acf                     lda xshi
   905  c495 49ff                       eor #$ff
   906                          
   907  c497 ae6ecf             ++      ldx frachi      ; check put mode
   908  c49a f03b                       beq ++          ; branch if zero
   909  c49c e001               +       cpx #1
   910  c49e d00a                       bne +           ; branch if not or mode
   911                                  ; or mode
   912  c4a0 b1fe                       lda (ptrl),y    ; keep all previous bits
   913  c4a2 0d6dcf                     ora fraclo      ; combine with what to put
   914  c4a5 91fe                       sta (ptrl),y    ; store result
   915  c4a7 4cdec4                     jmp +++
   916  c4aa e002               +       cpx #2
   917  c4ac d00a                       bne +
   918                                  ; and mode
   919  c4ae b1fe                       lda (ptrl),y    ; keep all previous bits
   920  c4b0 2d6dcf                     and fraclo      ; combine with what to put
   921  c4b3 91fe                       sta (ptrl),y    ; store result
   922  c4b5 4cdec4                     jmp +++
   923  c4b8 e003               +       cpx #3
   924  c4ba d00a                       bne +           ; branch if not eor mode
   925                                  ; eor mode
   926  c4bc b1fe                       lda (ptrl),y    ; keep all previous bits
   927  c4be 4d6dcf                     eor fraclo      ; combine with what to put
   928  c4c1 91fe                       sta (ptrl),y    ; store result
   929  c4c3 4cdec4                     jmp +++
   930  c4c6 e040               +       cpx #$40
   931  c4c8 d014                       bne +++         ; branch if not not mode
   932                                  ; not/erase mode
   933  c4ca b1fe                       lda (ptrl),y    ; keep all previous bits
   934  c4cc 0d6dcf                     ora fraclo      ; turn on bits
   935  c4cf 4d6dcf                     eor fraclo      ; invert to erase
   936  c4d2 91fe                       sta (ptrl),y    ; store result
   937  c4d4 4cdec4                     jmp +++
   938                          
   939                                  ; store mode
   940  c4d7 31fe               ++      and (ptrl),y    ; mask what to keep
   941  c4d9 0d6dcf                     ora fraclo      ; combine with what to put
   942  c4dc 91fe                       sta (ptrl),y    ; store result
   943                          
   944  c4de e6fe               +++     inc ptrl        ; ++ptr
   945  c4e0 d002                       bne +
   946  c4e2 e6ff                       inc ptrh
   947  c4e4 a5fe               +       lda ptrl
   948                          
   949  c4e6 2907                       and #$07        ; (ptr & 7) == 0) ?
   950  c4e8 d00d                       bne +           ; branch if no
   951  c4ea 18                         clc             ; yes - ptr += 312
   952  c4eb a5fe                       lda ptrl
   953  c4ed 6938                       adc #<312
   954  c4ef 85fe                       sta ptrl
   955  c4f1 a5ff                       lda ptrh
   956  c4f3 6901                       adc #>312
   957  c4f5 85ff                       sta ptrh
   958                          
   959  c4f7 2c5dcf             +       bit pattern_flag
   960  c4fa 7006                       bvs +           ; skip if pattern
   961  c4fc e6fc                       inc arg2        ; ++src
   962  c4fe d002                       bne +
   963  c500 e6fd                       inc arg3
   964                          
   965  c502 ce6bcf             +       dec yslo        ; next y
   966  c505 f003                       beq +
   967  c507 4c25c4                     jmp --
   968                          
   969  c50a 18                 +       clc             ; x1 += 8
   970  c50b ad63cf                     lda x1lo
   971  c50e 6908                       adc #8
   972  c510 8d63cf                     sta x1lo
   973  c513 9003                       bcc +
   974  c515 ee64cf                     inc x1hi
   975                          
   976  c518 a9ff               +       lda #$ff        ; interior - not left column anymore
   977  c51a 8d6acf                     sta xshi        ; left_mask
   978                          
   979  c51d ad6fcf                     lda incr        ; check if was first/left column
   980  c520 f014                       beq +
   981  c522 ce6fcf                     dec incr        ; reset to zero
   982  c525 2c5dcf                     bit pattern_flag
   983  c528 700c                       bvs +           ; skip if pattern
   984  c52a 38                         sec             ; reset source pointer to left most data by rewinding y distance bytes
   985  c52b a5fc                       lda arg2        ;  because we are now going to shift two sets of data together
   986  c52d ed6ccf                     sbc yshi
   987  c530 85fc                       sta arg2
   988  c532 b002                       bcs +
   989  c534 c6fd                       dec arg3        
   990                          
   991  c536 203bc1             +       jsr xyaddr      ; get next src addr into ptr
   992                          
   993  c539 ad6ccf                     lda yshi        ; restore y distance
   994  c53c 8d6bcf                     sta yslo
   995                          
   996  c53f ce69cf                     dec xslo        ; next x column (always a byte)
   997  c542 f003                       beq +
   998  c544 4c25c4                     jmp --
   999                          
  1000  c547 a5fc               +       lda arg2        ; put end of buffer in x,y registers
  1001  c549 aa                         tax
  1002  c54a a5fd                       lda arg3
  1003  c54c a8                         tay
  1004                          
  1005  c54d 2c16c0                     bit option_apply_color
  1006  c550 5006                       bvc +
  1007                          
  1008  c552 20dfc0                     jsr bankram     ; required in case was char rom
  1009  c555 202fd3                     jsr case11_apply_color
  1010                          
  1011  c558 4ce7c0             +	jmp banknorm    ; no matter what, go back to normal banking
  1012                          
  1013                          pattern
  1014  c55b a940                       lda #$40        ; BIT $pattern_flag will set overflow
  1015  c55d 8d5dcf                     sta pattern_flag ; YES PATTERN
  1016  c560 4c61c3                     jmp case11b
  1017                          
  1018                          case12           ; screen swap
  1019  c563 20dfc0                     jsr bankram
  1020  c566 20cfd3                     jsr screen_swap
  1021  c569 4ce7c0                     jmp banknorm
  1022                          
  1023                          hires_to_color
  1024  c56c 4a                         lsr
  1025  c56d 4a                         lsr
  1026  c56e 4a                         lsr
  1027  c56f 4a                         lsr
  1028  c570 4a                         lsr
  1029  c571 aa                         tax
  1030  c572 bd17c0                     lda option_colors_0,x
  1031  c575 60                         rts
  1032                          
  1033                          case13          ; draw character at prior set location, screen character X, high bit in Y
  1034  c576 8a                         txa
  1035  c577 48                         pha             ; save x register to stack
  1036  c578 98                         tya
  1037  c579 48                         pha             ; save y register to stack
  1038                          
  1039                                  ;               calculate (x2,y2) for character placment
  1040  c57a 18                         clc
  1041  c57b ad63cf                     lda x1lo
  1042  c57e 6907                       adc #7
  1043  c580 8d66cf                     sta x2lo
  1044  c583 ad64cf                     lda x1hi
  1045  c586 6900                       adc #0
  1046  c588 8d67cf                     sta x2hi
  1047  c58b 18                         clc
  1048  c58c ad65cf                     lda y1
  1049  c58f 6907                       adc #7
  1050  c591 8d68cf                     sta y2
  1051  c594 2017c2                     jsr case9c      ; call shape size operation
  1052  c597 e000                       cpx #0
  1053  c599 d00a                       bne +
  1054  c59b c000                       cpy #0
  1055  c59d d006                       bne +
  1056  c59f a8                         tay             ; set Y to zero for high size byte
  1057  c5a0 68                         pla             ; reclaim y register from stack
  1058  c5a1 68                         pla             ; reclaim x register from stack
  1059  c5a2 a200                       ldx #0          ; set X to zero for low size byte
  1060  c5a4 60                         rts             ; size failed
  1061                          
  1062                                  ;               compute address of character in rom
  1063                                  ;                 multiply character by 8, then add to $D000
  1064  c5a5 68                 +       pla             ; restore character high bit and mode from stack
  1065  c5a6 8502                       sta arg4        ; store in arg4 for mode
  1066  c5a8 2901                       and #$01        ; just need one bit for high bit of character
  1067  c5aa a8                         tay             ; character high bit in Y
  1068  c5ab 68                         pla             ; restore character low byte from stack
  1069  c5ac 85fb                       sta arg1        ; store character into arg1
  1070  c5ae 98                         tya             ; high byte moved to accumulator
  1071                          
  1072  c5af 06fb                       asl arg1        ; *2
  1073  c5b1 2a                         rol
  1074                          
  1075  c5b2 26fb                       rol arg1        ; *2
  1076  c5b4 2a                         rol
  1077                          
  1078  c5b5 26fb                       rol arg1        ; *2
  1079  c5b7 2a                         rol
  1080                          
  1081  c5b8 18                         clc
  1082  c5b9 69d0                       adc #$d0        ; character rom high byte
  1083  c5bb 85fc                       sta arg2
  1084                          
  1085                                  ;               put character shape
  1086  c5bd 78                         sei
  1087  c5be a501                       lda $01
  1088  c5c0 0901                       ora #$01        ; a000-bfff ROM
  1089  c5c2 29f9                       and #$f9        ; character ROM and e000-ffff RAM
  1090  c5c4 8501                       sta $01
  1091  c5c6 a6fb                       ldx arg1
  1092  c5c8 a4fc                       ldy arg2
  1093  c5ca a502                       lda arg4
  1094  c5cc 20d7c5                     jsr setnvzcflags; set shape mode to put normal (overwrite)
  1095  c5cf a90b                       lda #11
  1096  c5d1 2000c0                     jsr start       ; put shape and restore memory map defaults
  1097  c5d4 4ce7c0             	jmp banknorm    ; restore normal banking just in case
  1098                          
  1099                          setnvzcflags ; set NV----ZC flags based on accumulator, same positioning as CPU
  1100                                       ; not ---BDI-- flags
  1101                                       ;  effectively saving other registers and flags
  1102  c5d7 08                         php             ; save current flags at what will be 102+X
  1103  c5d8 48                         pha             ; save A register at what will be 101+X
  1104  c5d9 8a                         txa
  1105  c5da 48                         pha             ; save X register at what will be 100+X
  1106  c5db ba                         tsx             ; put SP into X
  1107  c5dc e8                         inx             ; adjust to point to last entry to stack
  1108  c5dd bd0101                     lda $101,x      ; retrieve desired flags
  1109  c5e0 29c3                       and #$c3        ; only what to change bits 7,6,1,0
  1110  c5e2 9d0101                     sta $101,x
  1111  c5e5 bd0201                     lda $102,x      ; retrieve original flags into accumulator
  1112  c5e8 293c                       and #$3c        ; mask bits that we don't want to change
  1113  c5ea 1d0101                     ora $101,x      ; combine with bits we want to change
  1114  c5ed 9d0201                     sta $102,x      ; store flags where we will retrieve later
  1115  c5f0 68                         pla
  1116  c5f1 aa                         tax             ; restore X register
  1117  c5f2 68                         pla             ; restore A register
  1118  c5f3 28                         plp             ; retrieve new flags
  1119  c5f4 60                         rts
  1120                          
  1121                          case14  ;               change foreground/background color at located pixel (color in arg2, arg3 must be 1 for hires)
  1122  c5f5 ad63cf                     lda x1lo
  1123  c5f8 8d79cf                     sta case14_x2lo
  1124  c5fb ad64cf                     lda x1hi
  1125  c5fe 8d7acf                     sta case14_x2hi
  1126  c601 ad65cf             	lda y1
  1127  c604 8d7bcf             	sta case14_y2
  1128  c607 a5fc                       lda arg2
  1129  c609 8d76cf                     sta case14_arg2
  1130  c60c a5fd                       lda arg3
  1131  c60e 8d75cf                     sta case14_arg1
  1132  c611 d001                       bne color_range
  1133                          
  1134  c613 60                 -      rts
  1135                          color_range ; given x1,y1,x2,y2, color in arg2, set color for range of pixels (text:arg1=0, hires:arg1=1)
  1136                                      ; note expects caller to validate x1,y1 in range
  1137                                      ; but we'll validate that x2>=x1, y2>=y1 and in range for proper operation
  1138                                      ; number of columns = ((x2 and $f8) - (x1 and $f8)) / 8 + 1
  1139  c614 38                         sec             ; compute number of columns
  1140  c615 ad63cf                     lda x1lo
  1141  c618 29f8                       and #$f8
  1142  c61a 8d77cf                     sta case14_arg3
  1143  c61d ad79cf                     lda case14_x2lo
  1144  c620 29f8                       and #$f8
  1145  c622 ed77cf                     sbc case14_arg3
  1146  c625 8d72cf                     sta case14_xslo
  1147  c628 ad7acf                     lda case14_x2hi
  1148  c62b ed64cf                     sbc x1hi
  1149  c62e 8d73cf                     sta case14_xshi
  1150  c631 90e0                       bcc -           ; exit if out of range
  1151  c633 4e73cf                     lsr case14_xshi ; xshi = xshi / 2
  1152  c636 d0db                       bne -           ; exit if out of range
  1153  c638 ad72cf                     lda case14_xslo
  1154  c63b 6a                         ror             ; = xshi remainder + xslo / 2
  1155  c63c 4a                         lsr             ; /= 2 (/4 so far)
  1156  c63d 4a                         lsr             ; /= 2 (/8)
  1157  c63e 18                         clc
  1158  c63f 6901                       adc #1          ; necessary to add one
  1159  c641 c929                       cmp #41
  1160  c643 9003                       bcc +
  1161  c645 4cdac6             	jmp ++          ; exit if out of range
  1162  c648 8d72cf             +       sta case14_xslo ; store number of columns
  1163                          
  1164  c64b 38                         sec             ; compute number of rows
  1165  c64c ad65cf                     lda y1
  1166  c64f 29f8                       and #$f8
  1167  c651 8d78cf                     sta case14_arg4
  1168  c654 ad7bcf                     lda case14_y2
  1169  c657 29f8                       and #$f8
  1170  c659 ed78cf                     sbc case14_arg4
  1171  c65c 907c                       bcc ++          ; exit if out of range
  1172  c65e 4a                         lsr 
  1173  c65f 4a                         lsr
  1174  c660 4a                         lsr
  1175  c661 18                         clc
  1176  c662 6901                       adc #1
  1177  c664 c91a                       cmp #26
  1178  c666 b072                       bcs ++          ; exit if out of range
  1179  c668 8d74cf                     sta case14_yslo ; store number of rows
  1180                          
  1181                                  ;               addr = gc + int(y1/8) * 40 + int(x1/8)
  1182  c66b ad64cf                     lda x1hi
  1183  c66e 4a                 	lsr
  1184  c66f ad63cf             	lda x1lo
  1185  c672 6a                         ror
  1186  c673 4a                         lsr
  1187  c674 4a                         lsr             ; int(x1/8)
  1188  c675 85fe                       sta ptrl
  1189  c677 ad14c0                     lda option_plotting
  1190  c67a 206cc5                     jsr hires_to_color
  1191  c67d ae75cf                     ldx case14_arg1
  1192  c680 d00c                       bne +
  1193  c682 ad76cf                     lda case14_arg2 ; text color is just foreground
  1194  c685 4a                         lsr
  1195  c686 4a                         lsr
  1196  c687 4a                         lsr
  1197  c688 4a                         lsr
  1198  c689 8d76cf                     sta case14_arg2
  1199  c68c a9d8                       lda #$d8        ; text color screen (I/O bank)
  1200  c68e 85ff               +       sta ptrh
  1201  c690 a205                       ldx #5          ; prep *5
  1202  c692 18                 -       clc
  1203  c693 a5fe                       lda ptrl
  1204  c695 6d78cf                     adc case14_arg4 ; int(y1/8)*8
  1205  c698 85fe                       sta ptrl
  1206  c69a 9002                       bcc +
  1207  c69c e6ff                       inc ptrh
  1208  c69e ca                 +       dex
  1209  c69f d0f1                       bne -
  1210                          
  1211  c6a1 ad75cf                     lda case14_arg1
  1212  c6a4 f006                       beq +           ; no need to switch banks if text color ram
  1213  c6a6 a501                       lda $01         ; save banks
  1214  c6a8 48                         pha
  1215  c6a9 20dfc0             	jsr bankram     ; ensure 64k ram bank
  1216                          +        
  1217                          
  1218  c6ac a000               --      ldy #0
  1219  c6ae ae72cf                     ldx case14_xslo
  1220  c6b1 ad76cf                     lda case14_arg2
  1221  c6b4 91fe               -       sta (ptrl),y
  1222  c6b6 c8                         iny             ; advance to next column
  1223  c6b7 ca                         dex
  1224  c6b8 d0fa                       bne -           ; loop for columns
  1225  c6ba 18                         clc             ; advance to next row
  1226  c6bb a5fe                       lda ptrl
  1227  c6bd 6928                       adc #40
  1228  c6bf 85fe                       sta ptrl
  1229  c6c1 9002                       bcc +
  1230  c6c3 e6ff                       inc ptrh 
  1231  c6c5 ce74cf             +       dec case14_yslo
  1232  c6c8 d0e2                       bne --          ; loop for rows
  1233                          
  1234  c6ca ad75cf                     lda case14_arg1
  1235  c6cd f00b                       beq ++          ; no need to switch banks if text color ram
  1236  c6cf 68                         pla
  1237  c6d0 aa                         tax
  1238  c6d1 2907                       and #$07        ; check if previous bank
  1239  c6d3 8601                       stx $01         ; restore banks to before
  1240  c6d5 c907                       cmp #$07        ; ...was normal
  1241  c6d7 d001                       bne ++          ; nope, no cli
  1242  c6d9 58                         cli
  1243  c6da 60                 ++      rts
  1244                          
  1245                          case15 ; copy text screen to graphics screen, and copy color too
  1246                                  ; initialize variables
  1247  c6db a900                       lda #0
  1248  c6dd 8d56cf                     sta copyx
  1249  c6e0 8d57cf                     sta copyx+1
  1250  c6e3 8d58cf                     sta copyy
  1251  c6e6 8d59cf                     sta copyptr
  1252  c6e9 a904                       lda #$04 ; text ram high byte
  1253  c6eb 8d5acf                     sta copyptr+1
  1254  c6ee a9e8                       lda #<(40*25)
  1255  c6f0 8d5bcf                     sta copycount
  1256  c6f3 a903                       lda #>(40*25)
  1257  c6f5 8d5ccf                     sta copycount+1
  1258                          
  1259                                  ; locate
  1260  c6f8 ae56cf             --      ldx copyx
  1261  c6fb ac58cf                     ldy copyy
  1262  c6fe ad57cf                     lda copyx+1
  1263  c701 4a                         lsr             ; move x high bit into C
  1264  c702 a907                       lda #7          ; locate op
  1265  c704 2000c0                     jsr start
  1266                          
  1267                                  ; copy char from text to graphics screen
  1268  c707 ad59cf                     lda copyptr
  1269  c70a 85fe                       sta ptrl
  1270  c70c ad5acf                     lda copyptr+1
  1271  c70f 85ff                       sta ptrh
  1272  c711 a000                       ldy #0
  1273  c713 b1fe                       lda (ptrl),y
  1274  c715 aa                         tax
  1275  c716 a90d                       lda #13         ; draw char
  1276  c718 2000c0                     jsr start
  1277                          
  1278                                  ; locate
  1279  c71b ae56cf                     ldx copyx
  1280  c71e ac58cf                     ldy copyy
  1281  c721 ad57cf                     lda copyx+1
  1282  c724 4a                         lsr             ; move x high bit into C
  1283  c725 a907                       lda #7          ; locate op
  1284  c727 2000c0                     jsr start
  1285                          
  1286                                  ; plot color
  1287  c72a ad59cf                     lda copyptr
  1288  c72d 85fe                       sta ptrl
  1289  c72f 18                         clc
  1290  c730 ad5acf                     lda copyptr+1
  1291  c733 69d4                       adc #>($d800-$0400)        ; translate text screen to color screen
  1292  c735 85ff                       sta ptrh
  1293  c737 a000                       ldy #0
  1294  c739 b1fe                       lda (ptrl),y
  1295  c73b 0a                         asl
  1296  c73c 0a                         asl
  1297  c73d 0a                         asl
  1298  c73e 0a                         asl
  1299  c73f 85fb                       sta arg1
  1300  c741 ad21d0                     lda $d021
  1301  c744 290f                       and #$f
  1302  c746 05fb                       ora arg1
  1303  c748 aa                         tax
  1304  c749 a90e                       lda #14
  1305  c74b a001               	ldy #1 ; graphics screen
  1306  c74d 2000c0                     jsr start
  1307                          
  1308  c750 18                         clc
  1309  c751 ad56cf                     lda copyx
  1310  c754 6908                       adc #8
  1311  c756 8d56cf                     sta copyx
  1312  c759 9003                       bcc +
  1313  c75b ee57cf                     inc copyx+1
  1314  c75e ad57cf             +       lda copyx+1
  1315  c761 f018                       beq +
  1316  c763 ad56cf                     lda copyx
  1317  c766 c940                       cmp #<320
  1318  c768 9011                       bcc +
  1319                          
  1320  c76a a900                       lda #0
  1321  c76c 8d56cf                     sta copyx
  1322  c76f 8d57cf                     sta copyx+1
  1323  c772 18                         clc
  1324  c773 ad58cf                     lda copyy
  1325  c776 6908                       adc #8
  1326  c778 8d58cf                     sta copyy
  1327                          
  1328  c77b ee59cf             +       inc copyptr
  1329  c77e d003                       bne +
  1330  c780 ee5acf                     inc copyptr+1
  1331                          
  1332  c783 ac5bcf             +       ldy copycount
  1333  c786 d003                       bne +
  1334  c788 ce5ccf                     dec copycount+1
  1335  c78b 88                 +       dey
  1336  c78c 8c5bcf                     sty copycount
  1337  c78f 98                         tya
  1338  c790 0d5ccf                     ora copycount+1
  1339  c793 f003                       beq +
  1340  c795 4cf8c6                     jmp --
  1341  c798 60                 +       rts
  1342                          
  1343                          ; this is a high performance multiplier, doing just shifts and adds, loops only 8 times
  1344                          multxy ; multiplies x*y, 16-bit result in xy (y is high byte), using stack for temporaries, code is relocatable
  1345  c799 d8                         cld             ; just in case
  1346  c79a 48                         pha             ; A saved
  1347  c79b a900                       lda #$00
  1348  c79d 48                         pha             ; result hi     @ $0105+SP
  1349  c79e 48                         pha             ; result lo     @ $0104+SP
  1350  c79f 48                         pha             ; multiplier hi @ $0103+SP
  1351  c7a0 98                         tya             ; y is multiplier lo
  1352  c7a1 48                         pha             ; multiplier lo @ $0102+SP
  1353  c7a2 8a                         txa             ; retrieve value x
  1354  c7a3 48                         pha             ; value x       @ $0101+SP
  1355  c7a4 ba                         tsx             ; x = SP stack pointer
  1356                          
  1357  c7a5 a008                       ldy #$08        ; nbits = 8
  1358  c7a7 5e0101             -       lsr $0101,x     ; get next bit of value x
  1359  c7aa 9013                       bcc +           ; if clear, skip add
  1360                          
  1361  c7ac 18                         clc             ; bit set, so result += multiplier
  1362  c7ad bd0401                     lda $0104,x     ; load result lo
  1363  c7b0 7d0201                     adc $0102,x     ; add mult lo
  1364  c7b3 9d0401                     sta $0104,x     ; store result lo
  1365  c7b6 bd0501                     lda $0105,x     ; load result hi
  1366  c7b9 7d0301                     adc $0103,x     ; add with carry mult hi
  1367  c7bc 9d0501                     sta $0105,x     ; store result hi
  1368                          
  1369  c7bf 1e0201             +       asl $0102,x     ; multiplier *= 2
  1370  c7c2 3e0301                     rol $0103,x
  1371                          
  1372  c7c5 88                         dey             ; --nbits
  1373  c7c6 d0df                       bne -           ; branch loop if nbits != 0
  1374                          
  1375                                                  ; give back stack space
  1376  c7c8 68                         pla             ; $0101+SP
  1377  c7c9 68                         pla             ; $0102+SP
  1378  c7ca 68                         pla             ; $0103+SP
  1379  c7cb 68                         pla             ; $0104+SP
  1380  c7cc aa                         tax             ; X = result lo
  1381  c7cd 68                         pla             ; $0105+SP
  1382  c7ce a8                         tay             ; Y = result hi
  1383  c7cf 68                         pla             ; A restored
  1384                          
  1385  c7d0 60                         rts
  1386                          
  1387                          list_tokens
  1388  c7d1 240f                       bit $0F   ; quoted?
  1389  c7d3 3008                       bmi +     ; if yes, handle normally in ROM
  1390  c7d5 c9cc                       cmp #$cc  ; compare to our first token value
  1391  c7d7 9004                       bcc +     ; skip token if less than ours
  1392  c7d9 c9d5                       cmp #$d5  ; compare past our last token value
  1393  c7db 9005                       bcc ++    ; branch if our token
  1394  c7dd 0900               +       ora #$00  ; reset Z flag for zero value
  1395  c7df 4c1aa7                     jmp $a71a ; process other token standard QPLOP
  1396  c7e2 8449               ++      sty $49   ; save index
  1397  c7e4 a000                       ldy #0
  1398  c7e6 38                         sec
  1399  c7e7 e9cc                       sbc #$cc
  1400  c7e9 aa                         tax
  1401  c7ea f00b                       beq +
  1402  c7ec b97dcf             -       lda tokens1,y
  1403  c7ef c8                         iny
  1404  c7f0 0900                       ora #0
  1405  c7f2 10f8                       bpl -
  1406  c7f4 ca                         dex
  1407  c7f5 d0f5                       bne -
  1408                          -
  1409  c7f7 b97dcf             +       lda tokens1,y
  1410  c7fa 3007                       bmi +
  1411  c7fc 2047ab                     jsr listchr
  1412  c7ff c8                         iny
  1413  c800 4cf7c7                     jmp -
  1414  c803 297f               +       and #$7f
  1415  c805 2047ab                     jsr listchr ; output character
  1416  c808 a449                       ldy $49   ; restore index
  1417  c80a 4c00a7                     jmp $a700 ; retrieve next token
  1418                          
  1419                          hires_crunch ; will be copy/patch of C64 BASIC crunch from A57C-A612
  1420  c80d 0000000000000000...!byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  1421  c81d 0000000000000000...!byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  1422  c82d 0000000000000000...!byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  1423  c83d 0000000000000000...!byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  1424  c84d 0000000000000000...!byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  1425  c85d 0000000000000000...!byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  1426  c86d 0000000000000000...!byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  1427  c87d 0000000000000000...!byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  1428  c88d 0000000000000000...!byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  1429  c89d 00000000000000     !byte 0,0,0,0,0,0,0
  1430                          
  1431                          patch_table
  1432  c8a4 37dfc8             !byte 0x37, <crunch_start, >crunch_start
  1433  c8a7 4002c9             !byte 0x40, <crunch_sbc, >crunch_sbc
  1434  c8aa 7eebc8             !byte 0x7e, <crunch_get, >crunch_get
  1435  c8ad 83f2c8             !byte 0x83, <crunch_next, >crunch_next
  1436  c8b0 00                 !byte 0
  1437                          
  1438                          crunch_patch
  1439  c8b1 a000                       ldy #0
  1440  c8b3 b97ca5             -       lda $a57c,y
  1441  c8b6 990dc8                     sta hires_crunch,y
  1442  c8b9 c8                         iny
  1443  c8ba c097                       cpy #$97
  1444  c8bc d0f5                       bne -
  1445                          
  1446  c8be a000                       ldy #0
  1447  c8c0 b9a4c8             -       lda patch_table,y
  1448  c8c3 f019                       beq +
  1449  c8c5 aa                         tax
  1450  c8c6 a920                       lda #$20 ; JSR opcode
  1451  c8c8 9d0dc8                     sta hires_crunch,x
  1452  c8cb e8                         inx
  1453  c8cc c8                         iny
  1454  c8cd b9a4c8                     lda patch_table,y
  1455  c8d0 9d0dc8                     sta hires_crunch,x
  1456  c8d3 e8                         inx
  1457  c8d4 c8                         iny
  1458  c8d5 b9a4c8                     lda patch_table,y
  1459  c8d8 9d0dc8                     sta hires_crunch,x
  1460  c8db c8                         iny
  1461  c8dc d0e2                       bne -
  1462  c8de 60                 +       rts
  1463                          
  1464                          crunch_start:
  1465  c8df a99e                       lda #<$A09E	; point to original BASIC tokens, low byte
  1466  c8e1 85fe                       sta ptrl
  1467  c8e3 a9a0                       lda #>$A09E	; point to original BASIC tokens, high byte
  1468  c8e5 85ff                       sta ptrh
  1469  c8e7 867a                       STX $7A
  1470  c8e9 ca                         DEX
  1471  c8ea 60                         rts
  1472                          crunch_get:		; retrieves character from token table, looking back one index
  1473  c8eb 88                         dey
  1474  c8ec b1fe                       lda (ptrl),y
  1475  c8ee c8                         iny
  1476  c8ef 0900                       ora #$00 ; restore N based on A (caller will BPL next)
  1477  c8f1 60                         rts
  1478                          crunch_next:
  1479  c8f2 c0ff                       cpy #$FF ; are we at the end of the last token in the first table?
  1480  c8f4 d009                       bne + ; no
  1481  c8f6 a97d                       lda #<tokens1 ; update low pointer to next table
  1482  c8f8 85fe                       sta ptrl
  1483  c8fa a9cf                       lda #>tokens1 ; update high pointer to next table
  1484  c8fc 85ff                       sta ptrh
  1485  c8fe c8                         iny ; reset index to zero, start of second token table
  1486  c8ff b1fe               +       lda (ptrl),y        
  1487  c901 60                         rts
  1488                          crunch_sbc:
  1489  c902 f1fe                       sbc (ptrl),y
  1490  c904 60                         rts
  1491                          
  1492                          get_coord ; retrieve x,y coordinates from command into a(xlo), x(y), y(xhi)
  1493  c905 20ebb7                     jsr getnum ; (16-bit [$14,$15] comma 8-bit [x])
  1494                          chk_coord
  1495  c908 e0c8                       cpx #200
  1496  c90a b00e                       bcs ++
  1497  c90c a514                       lda $14
  1498  c90e a415                       ldy $15
  1499  c910 f00b                       beq +
  1500  c912 c002                       cpy #2
  1501  c914 b004                       bcs ++
  1502  c916 c940                       cmp #<320
  1503  c918 9003                       bcc +
  1504  c91a 4ce3c9             ++      jmp .illegal_quantity
  1505  c91d 60                 +       rts
  1506                          
  1507                          chktoken:               ; re-check last token parsed
  1508  c91e a000                       ldy #0
  1509  c920 b17a                       lda ($7A),y
  1510  c922 38                         sec
  1511  c923 f002                       beq + ; continue
  1512  c925 c93a                       cmp #$3a ; colon
  1513  c927 60                 +       rts
  1514                          
  1515                          execute:
  1516  c928 207300                     jsr $0073 ; get next token (wedge)
  1517  c92b f02a                       beq loop ; end of line or colon
  1518  c92d 9028                       bcc loop ; numeric
  1519                          
  1520  c92f c9cc                       cmp #$cc ; HIRES?
  1521  c931 d003                       bne +
  1522  c933 4c05ca                     jmp hires
  1523  c936 c9cd               +	cmp #$cd ; COLOR?
  1524  c938 d003                       bne +
  1525  c93a 4c36cc                     jmp color
  1526  c93d c9ce               +       cmp #$ce ; PLOT?
  1527  c93f f021               	beq plot
  1528  c941 c9cf               +       cmp #$cf ; SHAPE?
  1529  c943 d003                       bne +
  1530  c945 4c3ccd                     jmp shape        
  1531  c948 c9d2               +       cmp #$d2 ; PATTERN?
  1532  c94a d003                       bne +
  1533  c94c 4c5ccd                     jmp shape_get_put ; syntax is similar
  1534  c94f c9d4               +       cmp #$d4 ; RECT?
  1535  c951 d003                       bne +
  1536  c953 4cc2cb                     jmp rect
  1537  c956 38                 +       sec ; non-numeric
  1538                                  ; not one of ours, continue with ROM processing
  1539  c957 4ce7a7             loop    jmp $a7e7 ; handle token
  1540                          
  1541  c95a 201ec9             reloop  jsr chktoken ; verify next token is end of statement
  1542  c95d f0f8                       beq loop        
  1543  c95f 4c08af                     jmp syntax_error ; syntax error
  1544                          
  1545  c962 20fbcd             plot	jsr lookahead
  1546  c965 c9cd                       cmp #$CD        ; COLOR
  1547  c967 d038                       bne ++
  1548  c969 207300                     jsr $0073       ; consume token
  1549  c96c a900                       lda #0
  1550  c96e 8d16c0                     sta option_apply_color
  1551  c971 20fbcd                     jsr lookahead
  1552  c974 d006                       bne +
  1553  c976 207300                     jsr $0073       ; consume token (end of line or colon)
  1554  c979 4c5ac9                     jmp reloop
  1555  c97c 2004cc             +       jsr commaorbyte
  1556  c97f 900c                       bcc +
  1557  c981 e010                       cpx #16
  1558  c983 b05e                       bcs .illegal_quantity
  1559  c985 8e1fc0                     stx option_hiresfg
  1560  c988 a940                       lda #$40
  1561  c98a 8d16c0                     sta option_apply_color
  1562  c98d 2004cc             +       jsr commaorbyte
  1563  c990 900c                       bcc +
  1564  c992 e010                       cpx #16
  1565  c994 b04d                       bcs .illegal_quantity
  1566  c996 8e20c0                     stx option_hiresbg
  1567  c999 a940                       lda #$40
  1568  c99b 8d16c0                     sta option_apply_color
  1569  c99e 4c5ac9             +       jmp reloop
  1570                          
  1571  c9a1 209bb7             ++      jsr getbytc     ; pixel state 0=clear, 1=set
  1572  c9a4 e002                       cpx #2
  1573  c9a6 b03b                       bcs .illegal_quantity
  1574  c9a8 8e5ecf                     stx plotcolor
  1575  c9ab c9a4                       cmp #$A4        ; TO token
  1576  c9ad f037                       beq plotto
  1577  c9af c940                       cmp #$40        ; @
  1578  c9b1 d009               	bne +
  1579  c9b3 20ffae             	jsr chkany
  1580  c9b6 2005c9             	jsr get_coord
  1581  c9b9 4cc2c9             	jmp plot_coord1
  1582  c9bc 20fdae             +       jsr chkcom      ; comma separates values
  1583                                  ; first coordinate before TO is locate
  1584  c9bf 201dce             	jsr plotstring		; check if is plot string, if is, does not return
  1585                          	; otherwise has called equivalent to get_coord
  1586                          	;jsr get_coord
  1587                          plot_coord1
  1588  c9c2 8d63cf                     sta x1lo                ; locate
  1589  c9c5 8c64cf                     sty x1hi
  1590  c9c8 8e65cf                     stx y1
  1591  c9cb 201ec9                     jsr chktoken
  1592  c9ce d00c                       bne + 
  1593  c9d0 ad63cf                     lda x1lo
  1594  c9d3 ac64cf                     ldy x1hi
  1595  c9d6 ae65cf                     ldx y1
  1596  c9d9 4cecc9                     jmp ++ ; drawing from/to same coord with draw pixel
  1597  c9dc c9a4               +       cmp #$A4
  1598  c9de f006                       beq plotto
  1599  c9e0 4c08af                     jmp syntax_error
  1600                          
  1601                          .illegal_quantity
  1602  c9e3 4c48b2                    jmp illegal_quantity ; invalid quantity error
  1603                          
  1604                          plotto
  1605  c9e6 207300                     jsr $0073               ; get next token
  1606  c9e9 2005c9                     jsr get_coord
  1607  c9ec 85fc               ++      sta arg2                ; setup args for drawto
  1608  c9ee 86fd                       stx arg3
  1609  c9f0 98                         tya
  1610  c9f1 ae5ecf                     ldx plotcolor
  1611  c9f4 d002                       bne +
  1612  c9f6 0902                       ora #2 ; pixel mode clear
  1613  c9f8 8502               +       sta arg4
  1614  c9fa 20ecc1                     jsr case8
  1615  c9fd 201ec9                     jsr chktoken
  1616  ca00 d0e4                       bne plotto
  1617  ca02 4c5ac9                     jmp reloop
  1618                          
  1619  ca05 209bb7             hires   jsr getbytc
  1620  ca08 c900                       cmp #0  ; end of line
  1621  ca0a d003                       bne +
  1622  ca0c 4cd9ca                     jmp hiresX
  1623  ca0f c93a               +       cmp #':' ; colon
  1624  ca11 d003                       bne +
  1625  ca13 4cd9ca                     jmp hiresX
  1626                          
  1627  ca16 c9d3               +       cmp #$d3 ; swap
  1628  ca18 d007                       bne +
  1629  ca1a a900                       lda #0
  1630  ca1c 8502               -       sta arg4
  1631  ca1e 4c5aca                     jmp hires_swap
  1632                          
  1633  ca21 c9a1               +       cmp #$a1 ; get
  1634  ca23 d004                       bne +
  1635  ca25 a940                       lda #$40 ; get option for swap
  1636  ca27 d0f3                       bne -
  1637                          
  1638  ca29 c9d0               +       cmp #$d0 ; put
  1639  ca2b d004                       bne +
  1640  ca2d a980                       lda #$80 ; put option for swap
  1641  ca2f d0eb                       bne -
  1642                          
  1643  ca31 c9ce               +       cmp #$ce ; plot
  1644  ca33 f011                       beq hires_plot
  1645                          
  1646  ca35 c99c                       cmp #$9c	; CLR token
  1647  ca37 d003                       bne +
  1648  ca39 4cd9ca                     jmp hiresX
  1649                          
  1650  ca3c c92c               +       cmp #','
  1651  ca3e d003                       bne +
  1652  ca40 4c0bcb                     jmp hires_addr
  1653                          
  1654  ca43 4c08af             +       jmp syntax_error
  1655                          
  1656                          hires_plot
  1657  ca46 207300                     jsr $0073
  1658  ca49 f003                       beq +
  1659  ca4b 4c08af                     jmp syntax_error
  1660  ca4e e000               +       cpx #0
  1661  ca50 d091                       bne .illegal_quantity
  1662  ca52 a90f                       lda #15 ; text to graphics
  1663  ca54 2000c0                     jsr start
  1664  ca57 4c5ac9                     jmp reloop
  1665                          
  1666                          hires_swap
  1667  ca5a 207300                     jsr $0073
  1668  ca5d f003                       beq +
  1669  ca5f 4c08af                     jmp syntax_error
  1670  ca62 e001               +       cpx #1
  1671  ca64 f003                       beq do_swap
  1672  ca66 4c48b2                     jmp illegal_quantity
  1673                          
  1674                          ; 0 poke 56,8*16+12:clr
  1675                          ; 10 hires 1,10*4096,(8*16+12)*256 clr plot
  1676                          ; 15 hires 1,14*4096 clr
  1677                          ; 20 plot 1 @ 0,0 to 319,199
  1678                          ; 30 hires 1 put
  1679                          ; 40 plot 1 @ 0,199 to 319,0
  1680                          ; 50 hires 1 swap
  1681                          ; 60 for i=1 to 100:next
  1682                          ; 70 goto 50
  1683                          do_swap
  1684  ca69 a502                       lda arg4
  1685  ca6b d026                       bne +                   ; GET or PUT, so just copy bytes, don't switch screens
  1686  ca6d ad15c0                     lda option_alternate    ; check if alt screen is physical hires screen
  1687  ca70 20a4ca                     jsr chk_phys_screen     ; check if hires bitmap and color screen valid and in same 16k segment
  1688  ca73 d01e                       bne +                   ; nope -- bitmap/color not in same 16K page
  1689                          
  1690                                  ; swap plotting/alternate, and activate new screen
  1691  ca75 ac15c0                     ldy option_alternate
  1692  ca78 ad14c0                     lda option_plotting
  1693  ca7b 8d15c0                     sta option_alternate
  1694  ca7e 8c14c0                     sty option_plotting
  1695  ca81 ad11d0             -       lda scroly
  1696  ca84 10fb                       bpl -                   ; wait for scan line out of visible area
  1697  ca86 a901                       lda #1
  1698  ca88 2000c0                     jsr start
  1699  ca8b a902                       lda #2
  1700  ca8d 2000c0                     jsr start
  1701  ca90 4c5ac9                     jmp reloop
  1702                          
  1703  ca93 a502               +       lda arg4
  1704  ca95 48                         pha
  1705  ca96 a90c                       lda #12 ; swap graphics screens
  1706  ca98 a200                       ldx #0
  1707  ca9a ac15c0                     ldy option_alternate
  1708  ca9d 28                         plp
  1709  ca9e 2000c0                     jsr start
  1710  caa1 4c5ac9                     jmp reloop
  1711                          
  1712                          chk_phys_screen
  1713  caa4 48                         pha
  1714  caa5 8a                         txa
  1715  caa6 48                         pha
  1716  caa7 98                         tya
  1717  caa8 48                         pha
  1718  caa9 ba                         tsx
  1719  caaa a901                       lda #1
  1720  caac 8d7ccf                     sta chk_phys_temp
  1721  caaf bd0301                     lda $103,x              ; retrieve A from stack
  1722  cab2 a8                         tay                     ; save copy in Y
  1723  cab3 f01b                       beq +                   ; nope - zero not allowed
  1724  cab5 291f                       and #$1F
  1725  cab7 d017                       bne +                   ; nope - offset not right
  1726  cab9 98                         tya
  1727  caba c980                       cmp #$80
  1728  cabc f012                       beq +                   ; nope - $8000 not allowed
  1729  cabe 29c0                       and #$C0                ; mask to 16K page
  1730  cac0 8d7ccf                     sta chk_phys_temp
  1731  cac3 98                         tya
  1732  cac4 206cc5                     jsr hires_to_color
  1733  cac7 29c0                       and #$C0
  1734  cac9 38                         sec
  1735  caca ed7ccf                     sbc chk_phys_temp
  1736  cacd 8d7ccf                     sta chk_phys_temp
  1737  cad0 68                 +       pla
  1738  cad1 a8                         tay
  1739  cad2 68                         pla
  1740  cad3 aa                         tax
  1741  cad4 68                         pla
  1742  cad5 ad7ccf                     lda chk_phys_temp       ; discard A, set Z for return value
  1743  cad8 60                         rts
  1744                          
  1745                          hiresX
  1746  cad9 e000                       cpx #0 ; HIRES 0
  1747  cadb d00d                       bne +
  1748  cadd ad11d0             -       lda scroly
  1749  cae0 10fb                       bpl -           ; make sure raster is in non-drawable part of screen
  1750  cae2 a905                       lda #5
  1751  cae4 2000c0                     jsr start
  1752  cae7 4c5ac9                     jmp reloop
  1753                          
  1754  caea e001               +       cpx #1 ; HIRES 1
  1755  caec f003                       beq +
  1756  caee 4ce3c9                     jmp .illegal_quantity
  1757  caf1 201ec9             +	jsr chktoken
  1758  caf4 f012               	beq +
  1759  caf6 a99c               	lda #$9c        ; CLR token
  1760  caf8 20ffae             	jsr chkany      ; check for token in A and advance
  1761                          
  1762                                  ; clear hires screen first
  1763  cafb a903                       lda #3
  1764  cafd 202ecd                     jsr gethirescolor ; in X without changing A
  1765  cb00 2000c0                     jsr start       ; set graphics color ram
  1766  cb03 a904                       lda #4
  1767  cb05 2000c0                     jsr start       ; clear graphics screen
  1768                          
  1769  cb08 4ca5cb             +       jmp switch_hires
  1770                          
  1771                          ; 100 poke 56,32:clr
  1772                          ; 105 goto 130
  1773                          ; 110 hires 1,8192,1024 clr
  1774                          ; 120 plot 1,0,0 to 319,199
  1775                          ; 130 hires 1,4*4096,6*4096 clr
  1776                          ; 140 plot 1,160,0 to 160,199
  1777                          ; 150 hires 1,10*4096,8*4096 clr
  1778                          ; 160 plot 1,319,0 to 0,199
  1779                          ; 165 stop
  1780                          ; 170 hires 1,14*4096 clr
  1781                          ; 180 plot 1,319,100 to 0,100
  1782                          ; 190 for i=0 to 1 step 0
  1783                          ; 200 hires 1,2*4096
  1784                          ; 210 hires 1,4*4096
  1785                          ; 220 hires 1,10*4096
  1786                          ; 230 hires 1,14*4096
  1787                          ; 240 get k$:i=len(k$)
  1788                          ; 250 next
  1789                          ; 260 hires 0:print chr$(147);
  1790                          hires_addr
  1791  cb0b 207300                     jsr $0073 ; skip comma
  1792  cb0e 208aad                     jsr frmnum
  1793  cb11 20f7b7                     jsr getadr
  1794  cb14 c000                       cpy #0
  1795  cb16 f003                       beq +
  1796  cb18 4c48b2             -       jmp illegal_quantity
  1797  cb1b cd14c0             +       cmp option_plotting
  1798  cb1e f009                       beq +
  1799  cb20 ac14c0                     ldy option_plotting
  1800  cb23 8c15c0                     sty option_alternate
  1801  cb26 8d14c0                     sta option_plotting
  1802  cb29 201ec9             +       jsr chktoken
  1803  cb2c c92c                       cmp #','
  1804  cb2e d01e                       bne +
  1805  cb30 20fdae                     jsr chkcom
  1806  cb33 208aad                     jsr frmnum
  1807  cb36 20f7b7                     jsr getadr
  1808  cb39 c000                       cpy #0
  1809  cb3b d0db                       bne -
  1810  cb3d a8                         tay             ; save color high address
  1811  cb3e ad14c0                     lda option_plotting
  1812  cb41 4a                         lsr             ; divide by 32 to get value 0..7
  1813  cb42 4a                         lsr
  1814  cb43 4a                         lsr
  1815  cb44 4a                         lsr
  1816  cb45 4a                         lsr
  1817  cb46 aa                         tax             ; x has # of hires screen (0..7)
  1818  cb47 98                         tya             ; restore color high address
  1819  cb48 9d17c0                     sta option_colors_0,x
  1820  cb4b 201ec9                     jsr chktoken
  1821  cb4e c9d3               +       cmp #$D3        ; SWAP
  1822  cb50 d035                       bne +
  1823  cb52 207300                     jsr $0073       ; consume SWAP
  1824  cb55 208aad                     jsr frmnum
  1825  cb58 20f7b7                     jsr getadr
  1826  cb5b c000                       cpy #0
  1827  cb5d d0b9                       bne -
  1828  cb5f 8d15c0                     sta option_alternate
  1829  cb62 201ec9                     jsr chktoken
  1830  cb65 c92c                       cmp #','
  1831  cb67 d01b                       bne +++
  1832  cb69 20fdae                     jsr chkcom
  1833  cb6c 208aad                     jsr frmnum
  1834  cb6f 20f7b7                     jsr getadr
  1835  cb72 c000                       cpy #0
  1836  cb74 d0a2                       bne -
  1837  cb76 a8                         tay             ; save color high address
  1838  cb77 ad15c0                     lda option_alternate
  1839  cb7a 4a                         lsr             ; divide by 32 to get value 0..7
  1840  cb7b 4a                         lsr
  1841  cb7c 4a                         lsr
  1842  cb7d 4a                         lsr
  1843  cb7e 4a                         lsr
  1844  cb7f aa                         tax             ; x has # of hires screen (0..7)
  1845  cb80 98                         tya             ; restore color high address
  1846  cb81 9d17c0                     sta option_colors_0,x
  1847  cb84 4c69ca             +++     jmp do_swap
  1848  cb87 c99c               +       cmp #$9C        ; CLR
  1849  cb89 d010                       bne +
  1850  cb8b a903                       lda #3
  1851  cb8d 202ecd                     jsr gethirescolor ; in X without changing A
  1852  cb90 2000c0                     jsr start
  1853  cb93 a904                       lda #4
  1854  cb95 2000c0                     jsr start
  1855  cb98 207300                     jsr $0073       ; consume token
  1856  cb9b c9ce               +       cmp #$CE        ; PLOT
  1857  cb9d d006                       bne +
  1858  cb9f 207300                     jsr $0073       ; consume token
  1859  cba2 4cbfcb                     jmp ++
  1860                          +      
  1861                          switch_hires
  1862  cba5 ad14c0                     lda option_plotting
  1863  cba8 20a4ca                     jsr chk_phys_screen
  1864  cbab f003                       beq +
  1865  cbad 4c48b2                     jmp illegal_quantity
  1866                          +
  1867  cbb0 ad11d0             -       lda scroly
  1868  cbb3 10fb                       bpl -           ; wait for raster off screen before switch screen
  1869  cbb5 a901                       lda #1
  1870  cbb7 2000c0                     jsr start
  1871  cbba a902                       lda #2
  1872  cbbc 2000c0                     jsr start        
  1873  cbbf 4c5ac9             ++      jmp reloop
  1874                          
  1875                          
  1876                          ; 10 hires 1 clr
  1877                          ; 20 x1%=rnd(1)*319
  1878                          ; 30 y1%=rnd(1)*199
  1879                          ; 40 x2%=rnd(1)*(320-x1%)
  1880                          ; 50 y2%=rnd(1)*(200-y1%)
  1881                          ; 60 rect rnd(1)*2,x1%,y1% to x2%,y2%
  1882                          ; 70 goto 20
  1883  cbc2 209bb7             rect    jsr getbytc
  1884  cbc5 8efdcb                     stx rect_pixel
  1885  cbc8 201ec9                     jsr chktoken
  1886  cbcb c92c                       cmp #','
  1887  cbcd f002                       beq +
  1888  cbcf a940                       lda #'@'
  1889  cbd1 20ffae             +       jsr chkany
  1890  cbd4 2005c9                     jsr get_coord
  1891  cbd7 8dfecb                     sta rect_x1lo
  1892  cbda 8cffcb                     sty rect_x1hi
  1893  cbdd 8e00cc                     stx rect_y1
  1894  cbe0 a9a4                       lda #$A4
  1895  cbe2 20ffae                     jsr chkany
  1896  cbe5 2005c9                     jsr get_coord
  1897  cbe8 8d01cc                     sta rect_x2lo
  1898  cbeb 8c02cc                     sty rect_x2hi
  1899  cbee 8e03cc                     stx rect_y2
  1900                          
  1901  cbf1 20dfc0                     jsr bankram
  1902  cbf4 2061d3                     jsr draw_rect
  1903  cbf7 20e7c0                     jsr banknorm
  1904                          
  1905  cbfa 4c5ac9                     jmp reloop        
  1906                          
  1907  cbfd 00                 rect_pixel !byte 0
  1908  cbfe 00                 rect_x1lo !byte 0
  1909  cbff 00                 rect_x1hi !byte 0
  1910  cc00 00                 rect_y1 !byte 0
  1911  cc01 00                 rect_x2lo !byte 0
  1912  cc02 00                 rect_x2hi !byte 0
  1913  cc03 00                 rect_y2 !byte 0
  1914                          
  1915                          commaorbyte
  1916  cc04 20fbcd                     jsr lookahead ; (past comma)
  1917  cc07 c900                       cmp #$00 ; end of line
  1918  cc09 d002                       bne +
  1919  cc0b 18                 -       clc
  1920  cc0c 60                         rts
  1921  cc0d c93a               +       cmp #$3a ; colon
  1922  cc0f f0fa                       beq -
  1923  cc11 c940                       cmp #$40 ; @
  1924  cc13 f0f6                       beq -
  1925  cc15 c92c                       cmp #$2c ; comma
  1926  cc17 d00e                       bne +
  1927  cc19 207300                     jsr $0073 ; get token
  1928  cc1c d005                       bne ++
  1929  cc1e 68                 -       pla
  1930  cc1f 68                         pla
  1931  cc20 4c08af                     jmp syntax_error
  1932  cc23 18                 ++      clc
  1933  cc24 a200                       ldx #0
  1934  cc26 60                         rts
  1935  cc27 209bb7             +       jsr getbytc
  1936  cc2a f008                       beq +
  1937  cc2c c92c                       cmp #$2c ; comma
  1938  cc2e f004                       beq +
  1939  cc30 c940                       cmp #$40 ; @
  1940  cc32 d0ea                       bne -
  1941  cc34 38                 +       sec
  1942  cc35 60                         rts
  1943                          
  1944                          color
  1945  cc36 2004cc                     jsr commaorbyte
  1946  cc39 900e                       bcc ++
  1947  cc3b c900                       cmp #$00
  1948  cc3d d003                       bne +
  1949  cc3f 4c08af                     jmp syntax_error; no arguments
  1950  cc42 e002               +       cpx #2 ; looking for 0 (text) or 1 (hires)
  1951  cc44 9003                       bcc ++
  1952  cc46 4ce3c9             -       jmp .illegal_quantity
  1953  cc49 86fc               ++      stx arg2        ; graphics mode (0 or 1)
  1954  cc4b a900                       lda #0
  1955  cc4d 85fb                       sta arg1        ; whether to apply color to screen
  1956  cc4f ad1fc0                     lda option_hiresfg
  1957  cc52 85fd                       sta arg3        ; save in case we need to restore
  1958  cc54 ad20c0                     lda option_hiresbg
  1959  cc57 8502                       sta arg4        ; save in case we need to restore
  1960  cc59 2004cc                     jsr commaorbyte
  1961  cc5c 9009                       bcc +
  1962  cc5e e010                       cpx #16
  1963  cc60 b0e4                       bcs -
  1964  cc62 8e1fc0                     stx option_hiresfg
  1965  cc65 e6fb                       inc arg1        ; set flag to apply fg color to screen
  1966  cc67 c940               +       cmp #$40 ; @
  1967  cc69 f028                       beq ++
  1968  cc6b 2004cc             +       jsr commaorbyte
  1969  cc6e 900f                       bcc +
  1970  cc70 e010                       cpx #16
  1971  cc72 b0d2                       bcs -
  1972  cc74 8e20c0                     stx option_hiresbg
  1973  cc77 48                         pha
  1974  cc78 a5fb                       lda arg1
  1975  cc7a 0902                       ora #$02        ; set flag to apply bg color to screen
  1976  cc7c 85fb                       sta arg1
  1977  cc7e 68                         pla
  1978  cc7f c940               +       cmp #$40 ; @
  1979  cc81 f010                       beq ++
  1980  cc83 2004cc                     jsr commaorbyte
  1981  cc86 9007                       bcc +
  1982  cc88 e010                       cpx #16
  1983  cc8a b0ba                       bcs -
  1984  cc8c 8e20d0                     stx $d020 ; border
  1985  cc8f c940               +       cmp #$40
  1986  cc91 d067                       bne .chkstor
  1987  cc93 207300             ++      jsr $0073
  1988  cc96 2005c9                     jsr get_coord
  1989  cc99 8d63cf                     sta x1lo
  1990  cc9c 8c64cf                     sty x1hi
  1991  cc9f 8e65cf                     stx y1
  1992  cca2 8d79cf                     sta case14_x2lo
  1993  cca5 8c7acf                     sty case14_x2hi
  1994  cca8 8e7bcf                     stx case14_y2
  1995  ccab 201ec9                     jsr chktoken        
  1996  ccae f016                       beq ++
  1997  ccb0 c9a4                       cmp #$a4        ; TO token
  1998  ccb2 f003                       beq +
  1999  ccb4 4c08af                     jmp syntax_error
  2000  ccb7 207300             +       jsr $0073
  2001  ccba 2005c9                     jsr get_coord
  2002  ccbd 8d79cf                     sta case14_x2lo
  2003  ccc0 8c7acf                     sty case14_x2hi
  2004  ccc3 8e7bcf                     stx case14_y2
  2005  ccc6 202ecd             ++      jsr gethirescolor
  2006  ccc9 a5fc                       lda arg2        ; hires(1) or text(0)?
  2007  cccb 8d75cf                     sta case14_arg1
  2008  ccce 8e76cf                     stx case14_arg2
  2009  ccd1 d017                       bne +           ; skip multiply if hires
  2010                                  ; lda x1hi
  2011                                  ; ora x2hi
  2012                                  ; bne .illegal_quantity
  2013                                  ; lda x1lo
  2014                                  ; cmp #40
  2015                                  ; bcs .illegal_quantity
  2016                                  ; lda x2lo
  2017                                  ; cmp #40
  2018                                  ; bcs .illegal_quantity
  2019                                  ; lda y1
  2020                                  ; cmp #25
  2021                                  ; bcs .illegal_quantity
  2022                                  ; lda y2
  2023                                  ; cmp #25
  2024                                  ; bcs .illegal_quantity
  2025  ccd3 a203                       ldx #3
  2026  ccd5 0e63cf             -       asl x1lo        ; multiply x1,y1,x2,y2 all by 8
  2027  ccd8 2e64cf                     rol x1hi        ;   to convert text coords to pixels
  2028  ccdb 0e79cf                     asl case14_x2lo
  2029  ccde 2e7acf                     rol case14_x2hi
  2030  cce1 0e65cf                     asl y1
  2031  cce4 0e7bcf                     asl case14_y2
  2032  cce7 ca                         dex
  2033  cce8 d0eb                       bne -
  2034  ccea a5fd               +       lda arg3
  2035  ccec 8d1fc0                     sta option_hiresfg     ; restore global color, just change region
  2036  ccef a502                       lda arg4
  2037  ccf1 8d20c0                     sta option_hiresbg     ; restore global color, just change region
  2038  ccf4 2014c6                     jsr color_range
  2039  ccf7 4c5ac9                     jmp reloop
  2040                          .chkstor
  2041  ccfa a5fc                       lda arg2
  2042  ccfc f00f                       beq .textcolor
  2043  ccfe a5fb                       lda arg1
  2044  cd00 f008                       beq +
  2045  cd02 202ecd                     jsr gethirescolor
  2046  cd05 a903                       lda #3
  2047  cd07 2000c0                     jsr start
  2048  cd0a 4c5ac9             +       jmp reloop
  2049                          .textcolor
  2050  cd0d a5fb                       lda arg1
  2051  cd0f 4a                         lsr
  2052  cd10 9006                       bcc +
  2053  cd12 ae1fc0                     ldx option_hiresfg
  2054  cd15 8e8602                     stx $286        ; text foreground
  2055  cd18 a6fd               +       ldx arg3
  2056  cd1a 8e1fc0                     stx option_hiresfg     ; restore global hires color because this was for text
  2057  cd1d 4a                         lsr
  2058  cd1e 9006                       bcc +
  2059  cd20 ae20c0                     ldx option_hiresbg
  2060  cd23 8e21d0                     stx $d021       ; background
  2061  cd26 a602               +       ldx arg4
  2062  cd28 8e20c0                     stx option_hiresbg     ; restore global hires color because this was for text
  2063  cd2b 4c5ac9                     jmp reloop
  2064                          
  2065                          gethirescolor ; returns in X, doesn't change A
  2066  cd2e 48                         pha
  2067  cd2f ad1fc0                     lda option_hiresfg
  2068  cd32 0a                         asl
  2069  cd33 0a                         asl
  2070  cd34 0a                         asl
  2071  cd35 0a                         asl
  2072  cd36 0d20c0                     ora option_hiresbg
  2073  cd39 aa                         tax
  2074  cd3a 68                         pla
  2075  cd3b 60                         rts
  2076                          
  2077  cd3c 207300             shape   jsr $0073
  2078  cd3f f018                       beq +
  2079  cd41 c9d0                       cmp #$d0 ; PUT?
  2080  cd43 f017                       beq shape_get_put
  2081  cd45 c9d1                       cmp #$d1 ; XOR?
  2082  cd47 f013                       beq shape_get_put
  2083  cd49 c9af                       cmp #$af ; AND?
  2084  cd4b f00f                       beq shape_get_put
  2085  cd4d c9b0                       cmp #$b0 ; OR?
  2086  cd4f f00b                       beq shape_get_put
  2087  cd51 c9a1                       cmp #$a1 ; GET?
  2088  cd53 f007                       beq shape_get_put
  2089  cd55 c9a8                       cmp #$a8 ; NOT?
  2090  cd57 f003                       beq shape_get_put
  2091  cd59 4c08af             +       jmp syntax_error
  2092                          
  2093                          shape_get_put
  2094  cd5c 85fb                       sta arg1
  2095  cd5e 207300                     jsr $0073 ; skip GET/PUT
  2096  cd61 208aad                     jsr frmnum
  2097  cd64 20f7b7                     jsr getadr
  2098  cd67 a614                       ldx $14
  2099  cd69 a415                       ldy $15
  2100  cd6b 86fe                       stx ptrl
  2101  cd6d 84ff                       sty ptrh
  2102  cd6f 201ec9                     jsr chktoken
  2103  cd72 c92c                       cmp #$2c ; comma?
  2104  cd74 f002                       beq +
  2105  cd76 a940                       lda #$40 ; if not comma, must be @
  2106  cd78 20ffae             +       jsr chkany ; check for token in A and advance
  2107  cd7b 2005c9                     jsr get_coord
  2108  cd7e 85fc                       sta arg2
  2109  cd80 86fd                       stx arg3
  2110  cd82 8402                       sty arg4
  2111  cd84 201ec9                     jsr chktoken
  2112  cd87 c92c                       cmp #$2c ; comma?
  2113  cd89 f002                       beq +
  2114  cd8b a9a4                       lda #$a4; if not comma, must be TO
  2115  cd8d 20ffae             +       jsr chkany ; check for token in A and advance
  2116  cd90 2005c9                     jsr get_coord
  2117  cd93 8d66cf                     sta x2lo
  2118  cd96 8c67cf                     sty x2hi
  2119  cd99 8e68cf                     stx y2
  2120  cd9c a5fc                       lda arg2
  2121  cd9e a6fd                       ldx arg3
  2122  cda0 a402                       ldy arg4
  2123  cda2 8d63cf                     sta x1lo
  2124  cda5 8c64cf                     sty x1hi
  2125  cda8 8e65cf                     stx y1
  2126  cdab a6fe                       ldx ptrl
  2127  cdad a4ff                       ldy ptrh
  2128  cdaf 86fc                       stx arg2
  2129  cdb1 84fd                       sty arg3
  2130  cdb3 a5fb                       lda arg1
  2131  cdb5 c9a1                       cmp #$a1 ; GET
  2132  cdb7 d006                       bne +
  2133  cdb9 2068c2                     jsr case10 ; GET SHAPE
  2134  cdbc 4c5ac9                     jmp reloop
  2135  cdbf c9d0               +       cmp #$d0 ; PUT
  2136  cdc1 d00a                       bne +        
  2137  cdc3 a900                       lda #0
  2138                          
  2139  cdc5 8502               -       sta arg4
  2140  cdc7 205cc3                     jsr case11 ; PUT SHAPE        
  2141  cdca 4c5ac9                     jmp reloop
  2142                                                          ; which PUT is it?
  2143  cdcd c9d1               +       cmp #$d1 ; XOR token
  2144  cdcf d004                       bne +
  2145  cdd1 a903                       lda #$03 ; XOR mode
  2146  cdd3 d0f0                       bne -
  2147                          
  2148  cdd5 c9b0               +       cmp #$b0 ; OR token
  2149  cdd7 d004                       bne +        
  2150  cdd9 a901                       lda #$01 ; OR mode
  2151  cddb d0e8                       bne -
  2152                          
  2153  cddd c9af               +       cmp #$af ; AND token
  2154  cddf d004                       bne +
  2155  cde1 a902                       lda #$02 ; AND mode
  2156  cde3 d0e0                       bne -
  2157                          
  2158  cde5 c9a8               +       cmp #$a8 ; NOT token
  2159  cde7 d004                       bne +
  2160  cde9 a940                       lda #$40 ; NOT mode
  2161  cdeb d0d8                       bne -
  2162                          
  2163  cded c9d2               +       cmp #$d2 ; PATTERN token
  2164  cdef d007                       bne +
  2165  cdf1 a900                       lda #0
  2166  cdf3 8502                       sta arg4
  2167  cdf5 205bc5                     jsr pattern
  2168                          
  2169  cdf8 4c5ac9             +       jmp reloop
  2170                          
  2171                          lookahead
  2172  cdfb a000                       ldy #0
  2173  cdfd b17a                       lda ($7A),y
  2174  cdff f01b                       beq +		; branch if end of line
  2175  ce01 c93a               	cmp #$3a	; colon
  2176  ce03 f017               	beq +		; branch if end of statement
  2177  ce05 a57a                       lda $7A
  2178  ce07 85fe                       sta ptrl
  2179  ce09 a57b                       lda $7B
  2180  ce0b 85ff                       sta ptrh
  2181  ce0d 207300                     jsr $0073
  2182  ce10 08                         php
  2183  ce11 48                         pha
  2184  ce12 a5fe                       lda ptrl
  2185  ce14 857a                       sta $7A
  2186  ce16 a5ff                       lda ptrh
  2187  ce18 857b                       sta $7B
  2188  ce1a 68                         pla
  2189  ce1b 28                         plp
  2190  ce1c 60                 +       rts
  2191                          
  2192                          plotstring
  2193  ce1d 209ead             	jsr frmevl	; evaluate expression
  2194  ce20 240d               	bit $d		; string or numeric?
  2195  ce22 301f               	bmi ++
  2196  ce24 20f7b7             	jsr getadr	; convert to integer
  2197  ce27 a614               	ldx $14
  2198  ce29 a415               	ldy $15
  2199  ce2b 86fb               	stx arg1
  2200  ce2d 84fc               	sty arg2
  2201  ce2f 201ec9                     jsr chktoken
  2202  ce32 c92c                       cmp #$2c        ; comma
  2203  ce34 f003                       beq +
  2204  ce36 4c08af                     jmp syntax_error
  2205  ce39 209bb7             +       jsr getbytc
  2206  ce3c a5fb               	lda arg1 
  2207  ce3e a4fc               	ldy arg2
  2208  ce40 4c08c9             	jmp chk_coord	; finish equivalent to get_coord, will return to plot
  2209                          
  2210  ce43 20a3b6             ++      jsr $b6a3	; pull string from descriptor stack (a=len, x=lo, y=hi addr of string)
  2211  ce46 8d5fcf                     sta plot_len
  2212  ce49 86fc                       stx arg2
  2213  ce4b 84fd                       sty arg3
  2214  ce4d 20fdae             	jsr chkcom      ; comma separates values
  2215  ce50 201ec9             	jsr chktoken
  2216  ce53 2005c9             	jsr get_coord
  2217  ce56 8d63cf                     sta x1lo
  2218  ce59 8c64cf                     sty x1hi
  2219  ce5c 8e65cf                     stx y1
  2220  ce5f 8d60cf             	sta plot_xlo
  2221  ce62 8c61cf             	sty plot_xhi
  2222  ce65 8e62cf             	stx plot_y
  2223  ce68 ad5fcf                     lda plot_len
  2224  ce6b c900               	cmp #$00
  2225  ce6d d003               	bne +
  2226  ce6f 4c34cf                     jmp ++++
  2227  ce72 a6fc               +       ldx arg2
  2228  ce74 a4fd                       ldy arg3
  2229  ce76 8664               	stx $64
  2230  ce78 8465               	sty $65
  2231                          
  2232  ce7a a900                       lda #0
  2233  ce7c 8d71cf                     sta charrvs
  2234  ce7f 8d70cf                     sta charlow
  2235                          
  2236  ce82 a000               -	ldy #0          ; draw next character
  2237  ce84 b164               	lda ($64),y
  2238  ce86 c90e               	cmp #$0E
  2239  ce88 d008               	bne +
  2240  ce8a a901               	lda #1
  2241  ce8c 8d70cf             	sta charlow
  2242  ce8f 4c26cf             	jmp ++
  2243  ce92 c98e               +	cmp #$8E
  2244  ce94 d008               	bne +
  2245  ce96 a900               	lda #0
  2246  ce98 8d70cf             	sta charlow
  2247  ce9b 4c26cf             	jmp ++
  2248  ce9e c912               +	cmp #$12
  2249  cea0 d007               	bne +
  2250  cea2 a980               	lda #$80
  2251  cea4 8d71cf             	sta charrvs
  2252  cea7 d07d               	bne ++
  2253  cea9 c992               +	cmp #$92
  2254  ceab d007               	bne +
  2255  cead a900               	lda #$00
  2256  ceaf 8d71cf             	sta charrvs
  2257  ceb2 f072               	beq ++	
  2258  ceb4 c920               +       cmp #$20
  2259  ceb6 906e                       bcc ++          ; skip if out of range
  2260  ceb8 c9ff                       cmp #$ff        ; pi?
  2261  ceba d004                       bne +++
  2262  cebc a95e                       lda #$5e        ; convert to pi screen code
  2263  cebe d02f                       bne +           ; display it
  2264  cec0 c9e0               +++     cmp #$e0
  2265  cec2 9004                       bcc +++         ; continue on if not e0..fe
  2266  cec4 e980                       sbc #$80        ; convert to screen code
  2267  cec6 d027                       bne +           ; display it
  2268  cec8 c9c0               +++     cmp #$c0        ; check if in range c0..df
  2269  ceca 9004                       bcc +++         ; continue on if not c0..df
  2270  cecc e980                       sbc #$80        ; convert to screen code
  2271  cece d01f                       bne +           ; display it
  2272  ced0 c9a0               +++     cmp #$a0
  2273  ced2 9005                       bcc +++         ; continue on if not a0..bf
  2274  ced4 38                         sec
  2275  ced5 e940                       sbc #$40
  2276  ced7 d016                       bne +           ; display it
  2277  ced9 c980               +++     cmp #$80
  2278  cedb b049                       bcs ++          ; skip if out of range 80..9f
  2279  cedd c940                       cmp #$40
  2280  cedf 900e                       bcc +           ; display if in range 20..3f
  2281  cee1 c960                       cmp #$60
  2282  cee3 b006                       bcs +++         ; branch if 60..7f
  2283  cee5 38                         sec             ; otherwise in range 40..5f
  2284  cee6 e940                       sbc #$40        ; convert ASCII to screen code
  2285  cee8 4cefce                     jmp +
  2286  ceeb e920               +++     sbc #$20        ; convert to screen code
  2287  ceed d000                       bne +           ; display it
  2288  ceef 18                 +	clc
  2289  cef0 6d71cf             	adc charrvs
  2290  cef3 aa                 	tax
  2291  cef4 ad70cf             	lda charlow
  2292  cef7 ac5ecf                     ldy plotcolor
  2293  cefa d002                       bne +
  2294  cefc 0940                       ora #$40        ; NOT mode
  2295  cefe a8                 +       tay
  2296  ceff 2076c5             	jsr case13      ; draw char
  2297                          
  2298  cf02 18                         clc             ; advance x, check for overflow
  2299  cf03 ad60cf                     lda plot_xlo
  2300  cf06 6908                       adc #8
  2301  cf08 8d60cf                     sta plot_xlo
  2302  cf0b 8d63cf                     sta x1lo
  2303  cf0e aa                         tax
  2304  cf0f ad61cf                     lda plot_xhi
  2305  cf12 6900                       adc #0
  2306  cf14 8d61cf                     sta plot_xhi
  2307  cf17 8d64cf                     sta x1hi
  2308  cf1a f004                       beq +
  2309  cf1c e039                       cpx #<313
  2310  cf1e b014                       bcs ++++
  2311  cf20 ad62cf             +       lda plot_y
  2312  cf23 8d65cf                     sta y1
  2313                          
  2314  cf26 e664               ++	inc $64
  2315  cf28 d002               	bne +
  2316  cf2a e665               	inc $65
  2317  cf2c ce5fcf             +	dec plot_len
  2318  cf2f f003               	beq ++++
  2319  cf31 4c82ce             	jmp -
  2320  cf34 68                 ++++	pla		; remove return address from cpu stack
  2321  cf35 68                 	pla
  2322  cf36 4c5ac9             	jmp reloop
  2323                          
  2324                          basic_error
  2325  cf39 48                         pha
  2326  cf3a c981                       cmp #$81        ; READY
  2327  cf3c f014                       beq +           ; skip if no error
  2328  cf3e ad11d0                     lda scroly      ; retrieve control register
  2329  cf41 2920                       and #$20        ; hires active?
  2330  cf43 f00d                       beq +           ; branch if not hires
  2331  cf45 8a                         txa
  2332  cf46 48                         pha
  2333  cf47 98                         tya
  2334  cf48 48                         pha
  2335  cf49 a905                       lda #5
  2336  cf4b 2000c0                     jsr start
  2337  cf4e 68                         pla
  2338  cf4f a8                         tay
  2339  cf50 68                         pla
  2340  cf51 aa                         tax
  2341                          
  2342  cf52 68                 +       pla             ; restore all registers
  2343  cf53 4c8be3                     jmp $e38b ; IERROR - Print BASIC Error Message Routine
  2344                          
  2345                          ; variables
  2346                          
  2347  cf56 0000               copyx !word 0
  2348  cf58 00                 copyy !byte 0
  2349  cf59 0000               copyptr !word 0
  2350  cf5b 0000               copycount !word 0
  2351                          
  2352  cf5d 00                 pattern_flag !byte 0
  2353                          
  2354  cf5e 00                 plotcolor !byte 0
  2355                          
  2356  cf5f 00                 plot_len !byte 0
  2357  cf60 00                 plot_xlo !byte 0
  2358  cf61 00                 plot_xhi !byte 0
  2359  cf62 00                 plot_y   !byte 0
  2360                          
  2361  cf63 00                 x1lo    !byte 0
  2362  cf64 00                 x1hi    !byte 0
  2363  cf65 00                 y1      !byte 0
  2364  cf66 00                 x2lo    !byte 0
  2365  cf67 00                 x2hi    !byte 0
  2366  cf68 00                 y2      !byte 0
  2367  cf69 00                 xslo    !byte 0
  2368  cf6a 00                 xshi    !byte 0
  2369  cf6b 00                 yslo    !byte 0
  2370  cf6c 00                 yshi    !byte 0
  2371  cf6d 00                 fraclo  !byte 0
  2372  cf6e 00                 frachi  !byte 0
  2373  cf6f 00                 incr    !byte 0
  2374                          
  2375  cf70 00                 charlow	!byte 0
  2376  cf71 00                 charrvs !byte 0
  2377                          
  2378                          ; coloring needs its own variables to not interfere with other uses
  2379  cf72 00                 case14_xslo !byte 0
  2380  cf73 00                 case14_xshi !byte 0
  2381  cf74 00                 case14_yslo !byte 0
  2382  cf75 00                 case14_arg1 !byte 0
  2383  cf76 00                 case14_arg2 !byte 0
  2384  cf77 00                 case14_arg3 !byte 0
  2385  cf78 00                 case14_arg4 !byte 0
  2386  cf79 00                 case14_x2lo !byte 0
  2387  cf7a 00                 case14_x2hi !byte 0
  2388  cf7b 00                 case14_y2 !byte 0
  2389                          
  2390  cf7c 00                 chk_phys_temp !byte 0
  2391                          
  2392                          ; 10 print chr$(147);
  2393                          ; 15 for i=0 to 1
  2394                          ; 20 for r=0 to 15
  2395                          ; 25 if i=0 then print spc(20);
  2396                          ; 30 for c=0 to 15
  2397                          ; 35 if i=0 and r<8 then:poke 1024+(r+17)*40+c,r*16+c
  2398                          ; 36 if i=0 and r>=8 then:poke 1024+(r+9)*40+c+20,r*16+c
  2399                          ; 37 if i=0 and ((r>=2 and r<8) or r>=10) then print chr$(r*16+c);
  2400                          ; 40 if i=1 then:plot 1,chr$(r*16+c),c*8,r*8
  2401                          ; 50 next c
  2402                          ; 54 if i=0 then print
  2403                          ; 55 next r
  2404                          ; 60 if i=0 then:printchr$(19):print:print"please wait...";:hires 0 swap:hires 1
  2405                          ; 70 next i
  2406                          ; 80 print "s";
  2407                          ; 90 for i=0 to 1 step 0:get k$:i=len(k$):next
  2408                          ; 100 hires 0
  2409                          
  2410                          ; 10 hires 1 clr
  2411                          ; 20 plot 1,"hires",rnd(1)*312,rnd(1)*192
  2412                          ; 30 goto 20
  2413                          
  2414                                  ; C64 tokens are A09E-A19E
  2415  cf7d 48495245           tokens1 !text "HIRE"            ; CC
  2416  cf81 d3                             !byte 'S' OR $80
  2417  cf82 434f4c4f                   !text "COLO"            ; CD
  2418  cf86 d2                             !byte 'R' OR $80
  2419  cf87 504c4f                     !text "PLO"             ; CE
  2420  cf8a d4                            !byte 'T' OR $80
  2421  cf8b 53484150                   !text "SHAP"            ; CF
  2422  cf8f c5                             !byte 'E' OR $80
  2423  cf90 5055                       !text "PU"              ; D0
  2424  cf92 d4                           !byte 'T' OR $80
  2425  cf93 584f                       !text "XO"              ; D1
  2426  cf95 d2                           !byte 'R' OR $80
  2427  cf96 504154544552               !text "PATTER"          ; D2
  2428  cf9c ce                            !byte 'N' OR $80
  2429  cf9d 535741                     !text "SWA"             ; D3
  2430  cfa0 d0                            !byte 'P' OR $80
  2431  cfa1 524543                     !text "REC"             ; D4
  2432  cfa4 d4                            !byte 'T' OR $80
  2433  cfa5 00                         !byte 0                 ; end of table
  2434                          
  2435                          scrledit_patch
  2436  cfa6 a52b                       lda $2b
  2437  cfa8 c901                       cmp #$01
  2438  cfaa d02a                       bne +
  2439  cfac a52c                       lda $2c
  2440  cfae c90d                       cmp #$0d
  2441  cfb0 d024                       bne +
  2442  cfb2 a9b9                       lda #$b9
  2443  cfb4 a29e                       ldx #$9e
  2444  cfb6 a0a0                       ldy #$a0
  2445  cfb8 cd2b0b                     cmp $0b2b
  2446  cfbb d019                       bne +
  2447  cfbd ec2c0b                     cpx $0b2c
  2448  cfc0 d014                       bne +
  2449  cfc2 cc2d0b                     cpy $0b2d
  2450  cfc5 d00f                       bne +
  2451  cfc7 a94c                       lda #$4c
  2452  cfc9 a2d7                       ldx #<scrledit_hook
  2453  cfcb a0cf                       ldy #>scrledit_hook
  2454  cfcd 8d1f0b                     sta $0b1f
  2455  cfd0 8e200b                     stx $0b20
  2456  cfd3 8c210b                     sty $0b21
  2457  cfd6 60                 +       rts        
  2458                          
  2459                          scrledit_hook
  2460  cfd7 38                         SEC
  2461  cfd8 e97f                       SBC #$7F
  2462  cfda c94c                       CMP #$4C
  2463  cfdc 901b                       BCC +
  2464  cfde c956                       CMP #$56
  2465  cfe0 b017                       BCS +
  2466  cfe2 e94b                       SBC #$4B
  2467  cfe4 48                         PHA
  2468  cfe5 a97d                       LDA #<tokens1
  2469  cfe7 a2cf                       LDX #>tokens1
  2470  cfe9 8d2c0b             -       STA $0B2C
  2471  cfec 8d340b                     STA $0B34
  2472  cfef 8e2d0b                     STX $0B2D
  2473  cff2 8e350b                     STX $0B35
  2474  cff5 68                         PLA
  2475  cff6 4c220b                     JMP $0B22
  2476  cff9 48                 +       PHA
  2477  cffa a99e                       LDA #$9E
  2478  cffc a2a0                       LDX #$A0
  2479  cffe d0e9                       BNE -
  2480                          
  2481  d000 ad64cf             fix_x   lda x1hi
  2482  d003 f017                       beq +++
  2483  d005 c901                       cmp #>319
  2484  d007 f007                       beq +
  2485  d009 a901                       lda #>319
  2486  d00b 8d64cf                     sta x1hi
  2487  d00e d007                       bne ++
  2488  d010 ad63cf             +       lda x1lo
  2489  d013 c93f                       cmp #<319
  2490  d015 9005                       bcc +++
  2491  d017 a93f               ++      lda #<319
  2492  d019 8d63cf                     sta x1lo
  2493  d01c 60                 +++     rts
  2494                                  
  2495  d01d ad14c0             case3   lda option_plotting
  2496  d020 206cc5                     jsr hires_to_color
  2497  d023 85ff                       sta ptrh
  2498                          
  2499  d025 a5fc                       lda arg2
  2500  d027 a204                       ldx #$04        ; 4 pages of 256 bytes
  2501  d029 a000                       ldy #0
  2502  d02b 84fe                       sty ptrl
  2503  d02d 8c16c0                     sty option_apply_color  ; clear option when initializing color
  2504                          initvr
  2505  d030 91fe                       sta (ptrl),y    ; set fg/bg of hires cell
  2506  d032 c8                         iny
  2507  d033 d0fb                       bne initvr
  2508  d035 e6ff                       inc ptrh
  2509  d037 ca                         dex
  2510  d038 d0f6                       bne initvr
  2511                          	
  2512  d03a 60                 	rts
  2513                          
  2514  d03b ad14c0             case4   lda option_plotting
  2515  d03e 85ff                       sta ptrh
  2516  d040 a900                       lda #0
  2517  d042 85fe                       sta ptrl
  2518  d044 a21f                       ldx #$1F ; number of pages, note: one less than full 8K
  2519  d046 a8                         tay
  2520                          loopclrg
  2521  d047 91fe                       sta (ptrl),y
  2522  d049 c8                         iny
  2523  d04a d0fb                       bne loopclrg
  2524  d04c e6ff                       inc ptrh
  2525  d04e ca                         dex
  2526  d04f d0f6                       bne loopclrg
  2527                          
  2528                          ; clear only part of last page 31*256+64 = 8000
  2529  d051 91fe               -       sta (ptrl),y
  2530  d053 c8                         iny
  2531  d054 c040                       cpy #$40
  2532  d056 d0f9                       bne -
  2533                          
  2534  d058 60                 	rts
  2535                          
  2536                          case6 ; set/clr pixel
  2537  d059 a5fc                       lda arg2 ; xc lo
  2538  d05b 8d63cf                     sta x1lo
  2539  d05e a5fd                       lda arg3 ; yc
  2540  d060 8d65cf                     sta y1
  2541  d063 a502                       lda arg4 ; xc hi and pixel color
  2542  d065 2901                       and #$01 ; isolate to xc hi
  2543  d067 8d64cf                     sta x1hi
  2544                          case6_from_line
  2545  d06a 203bc1                     jsr xyaddr
  2546                          
  2547  d06d ad63cf                     lda x1lo
  2548  d070 2907                       and #$07
  2549  d072 85fb                       sta arg1
  2550  d074 a907                       lda #$07
  2551  d076 a201                       ldx #$01
  2552  d078 38                         sec
  2553  d079 e5fb                       sbc arg1
  2554  d07b 86fb                       stx arg1
  2555  d07d a8                         tay
  2556  d07e c000                       cpy #$00
  2557  d080 f007                       beq shdone
  2558                          findbit
  2559  d082 06fb                       asl arg1
  2560  d084 88                         dey
  2561  d085 d0fb                       bne findbit
  2562  d087 f000                       beq shdone
  2563                          
  2564                          shdone
  2565  d089 a502                       lda arg4
  2566  d08b 2902                       and #$02
  2567  d08d aa                         tax
  2568  d08e b1fe                       lda (ptrl),y    ; note y is guaranteed zero by dey branch above
  2569  d090 05fb                       ora arg1
  2570  d092 e000                       cpx #$00        ; zero=set pixel, non-zero=clear pixel
  2571  d094 f002                       beq +
  2572  d096 45fb                       eor arg1
  2573  d098 91fe               +       sta (ptrl),y
  2574                                  ; fall through to check_apply_color
  2575                          
  2576                          ; 10 color 1,14,6,14
  2577                          ; 20 hires 1 clr
  2578                          ; 30 plot color rnd(1)*16
  2579                          ; 40 plot 1,rnd(1)*320,rnd(1)*200 : rem or plot to
  2580                          ; 50 goto 30
  2581                          check_apply_color
  2582  d09a 2c16c0                     bit option_apply_color ; check if need to apply color
  2583  d09d 502f                       bvc +
  2584  d09f a5fe                       lda ptrl
  2585  d0a1 48                         pha
  2586  d0a2 a5ff                       lda ptrh
  2587  d0a4 48                         pha
  2588  d0a5 ad63cf                     lda x1lo
  2589  d0a8 8d79cf                     sta case14_x2lo
  2590  d0ab ad64cf                     lda x1hi
  2591  d0ae 8d7acf                     sta case14_x2hi
  2592  d0b1 ad65cf             	lda y1
  2593  d0b4 8d7bcf             	sta case14_y2
  2594  d0b7 a901                       lda #1
  2595  d0b9 8d77cf                     sta case14_arg3
  2596  d0bc 8d75cf                     sta case14_arg1
  2597  d0bf 202ecd                     jsr gethirescolor
  2598  d0c2 8e76cf                     stx case14_arg2
  2599  d0c5 2014c6                     jsr color_range
  2600  d0c8 68                         pla
  2601  d0c9 85ff                       sta ptrh
  2602  d0cb 68                         pla
  2603  d0cc 85fe                       sta ptrl
  2604  d0ce 60                 +       rts
  2605                          
  2606                          line
  2607  d0cf 2000d0                     jsr fix_x   ; in case overrun from previous shape/plot/pattern operation
  2608  d0d2 38                         sec         ; xs(lope)=x2-x1
  2609  d0d3 ad66cf                     lda x2lo
  2610  d0d6 ed63cf                     sbc x1lo
  2611  d0d9 8d69cf                     sta xslo
  2612  d0dc ad67cf                     lda x2hi
  2613  d0df ed64cf                     sbc x1hi
  2614  d0e2 8d6acf                     sta xshi
  2615  d0e5 38                         sec         ; ys(lope)=y2-y1
  2616  d0e6 ad68cf                     lda y2
  2617  d0e9 ed65cf                     sbc y1
  2618  d0ec 8d6bcf                     sta yslo
  2619  d0ef a900                       lda #$00    ;extend sign so 16-bit
  2620  d0f1 e900                       sbc #$00
  2621  d0f3 8d6ccf                     sta yshi
  2622  d0f6 0d6bcf                     ora yslo    ; xs == 0 && ys == 0 ?
  2623  d0f9 0d6acf                     ora xshi
  2624  d0fc 0d69cf                     ora xslo
  2625  d0ff d003                       bne isline  ; no - is line
  2626  d101 4c6ad0                     jmp case6_from_line   ; yes- isdot
  2627                          isline
  2628  d104 a901                       lda #$01
  2629  d106 85fc                       sta arg2    ; arg2 (xs dir) = +1
  2630  d108 85fd                       sta arg3    ; arg3 (ys dir) = +1
  2631  d10a ad6acf                     lda xshi
  2632  d10d 1015                       bpl xpos    ; branch if xs is pos.
  2633  d10f a9ff                       lda #$ff
  2634  d111 85fc                       sta arg2    ; arg2 (xs dir) = -1
  2635  d113 38                         sec         ; xs = abs(xs)
  2636  d114 a900                       lda #$00
  2637  d116 ed69cf                     sbc xslo
  2638  d119 8d69cf                     sta xslo
  2639  d11c a900                       lda #$00
  2640  d11e ed6acf                     sbc xshi
  2641  d121 8d6acf                     sta xshi
  2642                          xpos
  2643  d124 ad6ccf                     lda yshi
  2644  d127 1015                       bpl ypos    ; branch if ys is pos.
  2645  d129 a9ff                       lda #$ff
  2646  d12b 85fd                       sta arg3    ; arg3 (ys dir) = -1
  2647  d12d 38                         sec         ; ys = abs(ys)
  2648  d12e a900                       lda #$00
  2649  d130 ed6bcf                     sbc yslo
  2650  d133 8d6bcf                     sta yslo
  2651  d136 a900                       lda #$00
  2652  d138 ed6ccf                     sbc yshi
  2653  d13b 8d6ccf                     sta yshi
  2654                          ypos
  2655                          
  2656  d13e ad6ccf                     lda yshi; ys(slope) >= xs(slope) ?
  2657  d141 cd6acf                     cmp xshi
  2658  d144 9010                       bcc ylower  ; no - branch if lower
  2659  d146 f003                       beq chklows ; equal - cmp lo bytes
  2660  d148 4c40d2                     jmp yhigher ; yes - absolute jump
  2661                          chklows
  2662  d14b ad6bcf                     lda yslo
  2663  d14e cd69cf                     cmp xslo
  2664  d151 9003                       bcc ylower  ; no - branch if lower
  2665  d153 4c40d2                     jmp yhigher ; yes - absolute jump
  2666                          
  2667                          ylower
  2668                          
  2669  d156 a5fd                       lda arg3    ; dir of ys(lope)
  2670  d158 1011                       bpl ypos2   ; positive, abs is ok
  2671  d15a 38                         sec         ; ys = -ys
  2672  d15b a900                       lda #$00
  2673  d15d ed6bcf                     sbc yslo
  2674  d160 8d6bcf                     sta yslo
  2675  d163 a900                       lda #$00
  2676  d165 ed6ccf                     sbc yshi
  2677  d168 8d6ccf                     sta yshi
  2678                          ypos2
  2679                          
  2680  d16b a5fc                       lda arg2    ; dir of xs(lope)
  2681  d16d 8d6fcf                     sta incr    ; used for step xi
  2682  d170 a900                       lda #$00    ; yfrac=0
  2683  d172 8d6dcf                     sta fraclo
  2684  d175 8d6ecf                     sta frachi
  2685                          
  2686                          forx:    ; for x=x1 to x2 step xi
  2687                          
  2688  d178 ad63cf                     lda x1lo    ; arg2=x1
  2689  d17b 85fc                       sta arg2
  2690  d17d ad65cf                     lda y1
  2691  d180 85fd                       sta arg3    ; arg3=y1
  2692  d182 4602                       lsr arg4    ; remove old x1 9th bit with shift right
  2693  d184 ad64cf                     lda x1hi
  2694  d187 2901                       and #$01
  2695  d189 4a                         lsr         ; move x1 9th bit into carry
  2696  d18a 2602                       rol arg4    ; rotate new x1 9th bit back in bit0, saving pixel color in bit1
  2697                          
  2698  d18c 2059d0                     jsr case6   ; plot point
  2699                          
  2700  d18f 18                         clc         ; yfrac += ys(lope)
  2701  d190 ad6dcf                     lda fraclo
  2702  d193 6d6bcf                     adc yslo
  2703  d196 8d6dcf                     sta fraclo
  2704  d199 ad6ecf                     lda frachi
  2705  d19c 6d6ccf                     adc yshi
  2706  d19f 8d6ecf                     sta frachi
  2707                          
  2708  d1a2 ad6ccf                     lda yshi    ; ys(lope) < 0 ?
  2709  d1a5 3034                       bmi ysneg   ; yes - branch
  2710  d1a7 f002                       beq chkyslo ; zero? chk low bits
  2711  d1a9 d005                       bne yspos   ; non-zero
  2712                          chkyslo
  2713  d1ab ad6bcf                     lda yslo
  2714  d1ae f060                       beq nextx   ; skip if zero
  2715                          yspos
  2716  d1b0 ad6ecf                     lda frachi  ; yfrac >= abs(xs) ?
  2717  d1b3 cd6acf                     cmp xshi
  2718  d1b6 9058                       bcc nextx  ; no - proceed to nextx
  2719  d1b8 d008                       bne incy1
  2720  d1ba ad6dcf                     lda fraclo
  2721  d1bd cd69cf                     cmp xslo
  2722  d1c0 904e                       bcc nextx
  2723                                     ; yes...
  2724                          incy1
  2725  d1c2 ee65cf                     inc y1      ; ++y1
  2726                          
  2727  d1c5 38                         sec         ; yfrac -= abs(xs)
  2728  d1c6 ad6dcf                     lda fraclo
  2729  d1c9 ed69cf                     sbc xslo
  2730  d1cc 8d6dcf                     sta fraclo
  2731  d1cf ad6ecf                     lda frachi
  2732  d1d2 ed6acf                     sbc xshi
  2733  d1d5 8d6ecf                     sta frachi
  2734                          
  2735  d1d8 18                         clc         ; force carry clear
  2736  d1d9 9035                       bcc nextx   ; abs branch nextx
  2737                          
  2738                          ysneg
  2739  d1db 38                         sec         ; yfrac <= -abs(xs) ?
  2740  d1dc a900                       lda #$00
  2741  d1de ed69cf                     sbc xslo
  2742  d1e1 85fe                       sta ptrl
  2743  d1e3 a900                       lda #$00
  2744  d1e5 ed6acf                     sbc xshi
  2745  d1e8 85ff                       sta ptrh
  2746  d1ea ad6ecf                     lda frachi
  2747  d1ed c5ff                       cmp ptrh
  2748  d1ef 901f                       bcc nextx
  2749  d1f1 d007                       bne decy1
  2750  d1f3 ad6dcf                     lda fraclo
  2751  d1f6 c5fe                       cmp ptrl
  2752  d1f8 9016                       bcc nextx
  2753                          decy1
  2754  d1fa ce65cf                     dec y1
  2755                          
  2756  d1fd 18                         clc
  2757  d1fe ad6dcf                     lda fraclo
  2758  d201 6d69cf                     adc xslo
  2759  d204 8d6dcf                     sta fraclo
  2760  d207 ad6ecf                     lda frachi
  2761  d20a 6d6acf                     adc xshi
  2762  d20d 8d6ecf                     sta frachi
  2763                          
  2764                          nextx
  2765  d210 ad64cf                     lda x1hi     ; x1 == x2 ?
  2766  d213 cd67cf                     cmp x2hi
  2767  d216 d00f                       bne stepx    ; no - so branch
  2768  d218 ad63cf                     lda x1lo
  2769  d21b cd66cf                     cmp x2lo
  2770  d21e d007                       bne stepx    ; no - so branch
  2771  d220 ad68cf                     lda y2       ; reload y2 and restore in y1
  2772  d223 8d65cf                     sta y1       ;   because have seen at -1
  2773  d226 60                         rts          ; yes - line is done
  2774                          
  2775                          stepx:      ; x += inc (+/- 1)
  2776  d227 a200                       ldx #$00     ; assume positive
  2777  d229 ad6fcf                     lda incr
  2778  d22c 1001                       bpl xnotneg
  2779  d22e ca                         dex          ; extend sign to regx
  2780                          xnotneg
  2781  d22f 18                         clc
  2782  d230 6d63cf                     adc x1lo
  2783  d233 8d63cf                     sta x1lo
  2784  d236 8a                         txa
  2785  d237 6d64cf                     adc x1hi
  2786  d23a 8d64cf                     sta x1hi
  2787                          
  2788                          bforx
  2789  d23d 4c78d1                     jmp forx
  2790                          
  2791                          yhigher
  2792                          
  2793  d240 a5fc                       lda arg2    ; dir of xs(lope)
  2794  d242 1011                       bpl xpos2   ; positive, abs is ok
  2795  d244 38                         sec         ; xs = -xs
  2796  d245 a900                       lda #$00
  2797  d247 ed69cf                     sbc xslo
  2798  d24a 8d69cf                     sta xslo
  2799  d24d a900                       lda #$00
  2800  d24f ed6acf                     sbc xshi
  2801  d252 8d6acf                     sta xshi
  2802                          xpos2
  2803                          
  2804  d255 a5fd                       lda arg3    ; dir of ys(lope)
  2805  d257 8d6fcf                     sta incr    ; used for step yi
  2806  d25a a900                       lda #$00    ; xfrac=0
  2807  d25c 8d6dcf                     sta fraclo
  2808  d25f 8d6ecf                     sta frachi
  2809                          
  2810                          fory:    ; for y=y1 to y2 step yi
  2811                          
  2812  d262 ad63cf                     lda x1lo    ; arg2=x1
  2813  d265 85fc                       sta arg2
  2814  d267 ad65cf                     lda y1
  2815  d26a 85fd                       sta arg3    ; arg3=y1
  2816  d26c 4602                       lsr arg4    ; remove old x1 9th bit with shift right
  2817  d26e ad64cf                     lda x1hi
  2818  d271 2901                       and #$01
  2819  d273 4a                         lsr         ; move x1 9th bit into carry
  2820  d274 2602                       rol arg4    ; rotate new x1 9th bit back in bit0, saving pixel color in bit1
  2821                          
  2822  d276 2059d0                     jsr case6   ; plot point
  2823                          
  2824  d279 18                         clc         ; xfrac += xs(lope)
  2825  d27a ad6dcf                     lda fraclo
  2826  d27d 6d69cf                     adc xslo
  2827  d280 8d6dcf                     sta fraclo
  2828  d283 ad6ecf                     lda frachi
  2829  d286 6d6acf                     adc xshi
  2830  d289 8d6ecf                     sta frachi
  2831                          
  2832  d28c ad6acf                     lda xshi    ; xs(lope) < 0 ?
  2833  d28f 3039                       bmi xsneg   ; yes - branch
  2834  d291 f002                       beq chkxslo ; zero? chk low bits
  2835  d293 d005                       bne xspos   ; non-zero
  2836                          chkxslo
  2837  d295 ad69cf                     lda xslo
  2838  d298 f073                       beq nexty   ; skip if zero
  2839                          xspos
  2840  d29a ad6ecf                     lda frachi  ; xfrac >= abs(ys) ?
  2841  d29d cd6ccf                     cmp yshi
  2842  d2a0 906b                       bcc nexty  ; no - proceed to nextx
  2843  d2a2 d008                       bne incx1
  2844  d2a4 ad6dcf                     lda fraclo
  2845  d2a7 cd6bcf                     cmp yslo
  2846  d2aa 9061                       bcc nexty
  2847                                     ; yes...
  2848                          incx1
  2849  d2ac ee63cf                     inc x1lo    ; ++x1
  2850  d2af d003                       bne noincxhi
  2851  d2b1 ee64cf                     inc x1hi
  2852                          noincxhi
  2853                          
  2854  d2b4 38                         sec         ; xfrac -= abs(ys)
  2855  d2b5 ad6dcf                     lda fraclo
  2856  d2b8 ed6bcf                     sbc yslo
  2857  d2bb 8d6dcf                     sta fraclo
  2858  d2be ad6ecf                     lda frachi
  2859  d2c1 ed6ccf                     sbc yshi
  2860  d2c4 8d6ecf                     sta frachi
  2861                          
  2862  d2c7 18                         clc         ; force carry clear
  2863  d2c8 9043                       bcc nexty   ; abs branch nexty
  2864                          
  2865                          xsneg
  2866                          
  2867  d2ca 38                         sec         ; xfrac <= -abs(ys) ?
  2868  d2cb a900                       lda #$00
  2869  d2cd ed6bcf                     sbc yslo
  2870  d2d0 85fe                       sta ptrl
  2871  d2d2 a900                       lda #$00
  2872  d2d4 ed6ccf                     sbc yshi
  2873  d2d7 85ff                       sta ptrh
  2874  d2d9 ad6ecf                     lda frachi
  2875  d2dc c5ff                       cmp ptrh
  2876  d2de 902d                       bcc nexty
  2877  d2e0 d007                       bne decx1
  2878  d2e2 ad6dcf                     lda fraclo
  2879  d2e5 c5fe                       cmp ptrl
  2880  d2e7 9024                       bcc nexty
  2881                          
  2882                          decx1
  2883  d2e9 38                         sec
  2884  d2ea ad63cf                     lda x1lo
  2885  d2ed e901                       sbc #$01
  2886  d2ef 8d63cf                     sta x1lo
  2887  d2f2 ad64cf                     lda x1hi
  2888  d2f5 e900                       sbc #$00
  2889  d2f7 8d64cf                     sta x1hi
  2890                          
  2891  d2fa 18                         clc
  2892  d2fb ad6dcf                     lda fraclo
  2893  d2fe 6d6bcf                     adc yslo
  2894  d301 8d6dcf                     sta fraclo
  2895  d304 ad6ecf                     lda frachi
  2896  d307 6d6ccf                     adc yshi
  2897  d30a 8d6ecf                     sta frachi
  2898                          
  2899                          nexty
  2900  d30d ad65cf                     lda y1       ; y1 == y2 ?
  2901  d310 cd68cf                     cmp y2
  2902  d313 d00d                       bne stepy    ; no - so branch
  2903  d315 ad66cf                     lda x2lo     ; reload x1 with x2 just in case
  2904  d318 8d63cf                     sta x1lo     ;   to avoid -1
  2905  d31b ad67cf                     lda x2hi
  2906  d31e 8d64cf                     sta x1hi
  2907  d321 60                         rts          ; yes - line is done
  2908                          
  2909                          stepy:      ; y += inc (+/- 1)
  2910  d322 18                         clc
  2911  d323 ad65cf                     lda y1
  2912  d326 6d6fcf                     adc incr
  2913  d329 8d65cf                     sta y1
  2914                          
  2915  d32c 4c62d2                     jmp fory
  2916                          
  2917                          ; end line
  2918                          
  2919                          case11_apply_color      ; shape/pattern put with color, after drawing shape, apply color to whole region
  2920  d32f ad72cf                     lda case14_xslo
  2921  d332 8d63cf                     sta x1lo
  2922  d335 ad73cf                     lda case14_xshi
  2923  d338 8d64cf                     sta x1hi
  2924  d33b ad74cf                     lda case14_yslo
  2925  d33e 8d65cf                     sta y1
  2926  d341 ad66cf                     lda x2lo
  2927  d344 8d79cf                     sta case14_x2lo
  2928  d347 ad67cf                     lda x2hi
  2929  d34a 8d7acf                     sta case14_x2hi
  2930  d34d ad68cf                     lda y2
  2931  d350 8d7bcf                     sta case14_y2
  2932  d353 a901                       lda #1
  2933  d355 8d75cf                     sta case14_arg1
  2934  d358 202ecd                     jsr gethirescolor
  2935  d35b 8e76cf                     stx case14_arg2
  2936  d35e 4c14c6                     jmp color_range
  2937                          
  2938                          draw_rect
  2939  d361 adfecb                     lda rect_x1lo
  2940  d364 8d63cf                     sta x1lo
  2941  d367 adffcb                     lda rect_x1hi
  2942  d36a 8d64cf                     sta x1hi
  2943  d36d ad00cc                     lda rect_y1
  2944  d370 8d65cf                     sta y1
  2945  d373 8d68cf                     sta y2
  2946  d376 ad01cc                     lda rect_x2lo
  2947  d379 8d66cf                     sta x2lo
  2948  d37c ad02cc                     lda rect_x2hi
  2949  d37f 8d67cf                     sta x2hi
  2950  d382 adfdcb                     lda rect_pixel
  2951  d385 0a                         asl
  2952  d386 4902                       eor #$02
  2953  d388 8502                       sta arg4
  2954  d38a 20cfd0                     jsr line
  2955                          
  2956  d38d ad01cc                     lda rect_x2lo
  2957  d390 8d66cf                     sta x2lo
  2958  d393 ad02cc                     lda rect_x2hi
  2959  d396 8d67cf                     sta x2hi
  2960  d399 ad03cc                     lda rect_y2
  2961  d39c 8d68cf                     sta y2
  2962  d39f adfdcb                     lda rect_pixel
  2963  d3a2 20cfd0                     jsr line
  2964                          
  2965  d3a5 adfecb                     lda rect_x1lo
  2966  d3a8 8d66cf                     sta x2lo
  2967  d3ab adffcb                     lda rect_x1hi
  2968  d3ae 8d67cf                     sta x2hi
  2969  d3b1 ad03cc                     lda rect_y2
  2970  d3b4 8d68cf                     sta y2
  2971  d3b7 20cfd0                     jsr line
  2972                          
  2973  d3ba adfecb                     lda rect_x1lo
  2974  d3bd 8d66cf                     sta x2lo
  2975  d3c0 adffcb                     lda rect_x1hi
  2976  d3c3 8d67cf                     sta x2hi
  2977  d3c6 ad00cc                     lda rect_y1
  2978  d3c9 8d65cf                     sta y1
  2979  d3cc 4ccfd0                     jmp line
  2980                          
  2981                          screen_swap
  2982  d3cf 8c15c0                     sty option_alternate
  2983  d3d2 86fe                       stx ptrl
  2984  d3d4 84ff                       sty ptrh
  2985  d3d6 ad14c0                     lda option_plotting
  2986  d3d9 85fc                       sta arg2
  2987  d3db a900                       lda #0
  2988  d3dd 85fb                       sta arg1
  2989  d3df a920                       lda #$20 ; 32 pages of 256 bytes
  2990  d3e1 85fd                       sta arg3
  2991  d3e3 2008d4                     jsr swap ; graphic screen
  2992                          
  2993                                  ; also swap color RAM between screens
  2994  d3e6 ad15c0                     lda option_alternate
  2995  d3e9 206cc5                     jsr hires_to_color
  2996  d3ec 85ff                       sta ptrh
  2997  d3ee ad14c0                     lda option_plotting
  2998  d3f1 206cc5                     jsr hires_to_color
  2999  d3f4 85fc                       sta arg2
  3000  d3f6 a000                       ldy #0
  3001  d3f8 84fe                       sty ptrl
  3002  d3fa 84fb                       sty arg1
  3003  d3fc a900                       lda #0
  3004  d3fe a904                       lda #$04 ; 4 pages of 256 bytes
  3005  d400 85fd                       sta arg3
  3006  d402 2008d4                     jsr swap
  3007  d405 4c89c0                     jmp install_no_interrupt ; in case swapped out
  3008                          
  3009                          swap
  3010  d408 a000                       ldy #$00
  3011  d40a 2402               -       bit arg4
  3012  d40c 7007                       bvs +           ; ptrl -> arg1 only
  3013  d40e b1fb                       lda (arg1),y
  3014  d410 a602                       ldx arg4
  3015  d412 300a                       bmi ++          ; arg1 -> ptrl only
  3016  d414 aa                         tax
  3017  d415 b1fe               +       lda (ptrl),y
  3018  d417 91fb                       sta (arg1),y
  3019  d419 2402                       bit arg4
  3020  d41b 7003                       bvs +
  3021  d41d 8a                         txa             ; swap in progress if here, ptrl <-> arg1
  3022  d41e 91fe               ++      sta (ptrl),y
  3023  d420 c8                 +       iny
  3024  d421 d0e7                       bne -
  3025  d423 e6fc                       inc arg2
  3026  d425 e6ff                       inc ptrh
  3027  d427 c6fd                       dec arg3
  3028  d429 d0df                       bne -
  3029  d42b 60                         rts
  3030                          finish
